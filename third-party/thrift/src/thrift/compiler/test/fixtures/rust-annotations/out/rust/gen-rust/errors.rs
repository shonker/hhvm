// @generated by Thrift for thrift/compiler/test/fixtures/rust-annotations/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `Service1`.
pub mod service1 {

    pub type RError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum RReader {}

    impl ::fbthrift::help::DeserializeExn for RReader {
        type Success = crate::types::T6;
        type Error = RError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "RError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "RError"),
                )
                .into(),
            )
        }
    }

}

#[doc(inline)]
#[allow(ambiguous_glob_reexports)]
pub use self::service1::*;

/// Error definitions for `S2`.
pub mod s2_proxy {

    pub type RError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum RReader {}

    impl ::fbthrift::help::DeserializeExn for RReader {
        type Success = crate::types::T6;
        type Error = RError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Struct, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "RError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "RError"),
                )
                .into(),
            )
        }
    }

}

#[doc(inline)]
#[allow(ambiguous_glob_reexports)]
pub use self::s2_proxy::*;

/// Error definitions for `AllMethods`.
pub mod all_methods {

    pub trait AsSomeError {
        fn as_some_error(&self) -> Option<&crate::types::SomeError>;
    }

    impl AsSomeError for ::anyhow::Error {
        fn as_some_error(&self) -> Option<&crate::types::SomeError> {
            for cause in self.chain() {
                if let Some(BarError::se(e)) = cause.downcast_ref::<BarError>() {
                    return Some(e);
                }
            }
            None
        }
    }

    pub type FooError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum FooReader {}

    impl ::fbthrift::help::DeserializeExn for FooReader {
        type Success = ();
        type Error = FooError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "FooError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    /// Errors for bar (client side).
    #[derive(Debug)]
    pub enum BarError {
        se(crate::types::SomeError),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BarError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::se(inner) => {
                    if f.alternate() {
                        write!(f, "AllMethods::bar failed with variant `se`: {:#}", inner)?;
                    } else {
                        write!(f, "AllMethods::bar failed with se(SomeError)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "AllMethods::bar failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "AllMethods::bar failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for BarError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::se(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::SomeError> for BarError {
        fn from(e: crate::types::SomeError) -> Self {
            Self::se(e)
        }
    }

    impl AsSomeError for BarError {
        fn as_some_error(&self) -> Option<&crate::types::SomeError> {
            match self {
                Self::se(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BarError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BarError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::all_methods::BarExn> for BarError {
        fn from(e: crate::services::all_methods::BarExn) -> Self {
            match e {
                crate::services::all_methods::BarExn::ApplicationException(aexn) =>
                    BarError::ApplicationException(aexn),
                crate::services::all_methods::BarExn::se(exn) =>
                    BarError::se(exn),
            }
        }
    }

    impl ::std::convert::From<BarError> for crate::services::all_methods::BarExn {
        fn from(err: BarError) -> Self {
            match err {
                BarError::se(err) => crate::services::all_methods::BarExn::se(err),
                BarError::ApplicationException(aexn) => crate::services::all_methods::BarExn::ApplicationException(aexn),
                BarError::ThriftError(err) => crate::services::all_methods::BarExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum BarReader {}

    impl ::fbthrift::help::DeserializeExn for BarReader {
        type Success = ::std::string::String;
        type Error = BarError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ::fbthrift::Field::new("se", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::String, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::se(::fbthrift::Deserialize::read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "BarError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "BarError"),
                )
                .into(),
            )
        }
    }

}

#[doc(inline)]
#[allow(ambiguous_glob_reexports)]
pub use self::all_methods::*;

/// Error definitions for `OneMethod`.
pub mod one_method {

    pub trait AsSomeError {
        fn as_some_error(&self) -> Option<&crate::types::SomeError>;
    }

    impl AsSomeError for ::anyhow::Error {
        fn as_some_error(&self) -> Option<&crate::types::SomeError> {
            for cause in self.chain() {
                if let Some(BarError::se(e)) = cause.downcast_ref::<BarError>() {
                    return Some(e);
                }
            }
            None
        }
    }

    pub type FooError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum FooReader {}

    impl ::fbthrift::help::DeserializeExn for FooReader {
        type Success = ();
        type Error = FooError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "FooError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    /// Errors for bar (client side).
    #[derive(Debug)]
    pub enum BarError {
        se(crate::types::SomeError),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BarError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::se(inner) => {
                    if f.alternate() {
                        write!(f, "OneMethod::bar failed with variant `se`: {:#}", inner)?;
                    } else {
                        write!(f, "OneMethod::bar failed with se(SomeError)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "OneMethod::bar failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "OneMethod::bar failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for BarError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::se(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::SomeError> for BarError {
        fn from(e: crate::types::SomeError) -> Self {
            Self::se(e)
        }
    }

    impl AsSomeError for BarError {
        fn as_some_error(&self) -> Option<&crate::types::SomeError> {
            match self {
                Self::se(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BarError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BarError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::one_method::BarExn> for BarError {
        fn from(e: crate::services::one_method::BarExn) -> Self {
            match e {
                crate::services::one_method::BarExn::ApplicationException(aexn) =>
                    BarError::ApplicationException(aexn),
                crate::services::one_method::BarExn::se(exn) =>
                    BarError::se(exn),
            }
        }
    }

    impl ::std::convert::From<BarError> for crate::services::one_method::BarExn {
        fn from(err: BarError) -> Self {
            match err {
                BarError::se(err) => crate::services::one_method::BarExn::se(err),
                BarError::ApplicationException(aexn) => crate::services::one_method::BarExn::ApplicationException(aexn),
                BarError::ThriftError(err) => crate::services::one_method::BarExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum BarReader {}

    impl ::fbthrift::help::DeserializeExn for BarReader {
        type Success = ::std::string::String;
        type Error = BarError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ::fbthrift::Field::new("se", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::String, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::se(::fbthrift::Deserialize::read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "BarError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "BarError"),
                )
                .into(),
            )
        }
    }

}

#[doc(inline)]
#[allow(ambiguous_glob_reexports)]
pub use self::one_method::*;

/// Error definitions for `OneMethodOptOut`.
pub mod one_method_opt_out {

    pub trait AsSomeError {
        fn as_some_error(&self) -> Option<&crate::types::SomeError>;
    }

    impl AsSomeError for ::anyhow::Error {
        fn as_some_error(&self) -> Option<&crate::types::SomeError> {
            for cause in self.chain() {
                if let Some(BarError::se(e)) = cause.downcast_ref::<BarError>() {
                    return Some(e);
                }
            }
            None
        }
    }

    pub type FooError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum FooReader {}

    impl ::fbthrift::help::DeserializeExn for FooReader {
        type Success = ();
        type Error = FooError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "FooError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    /// Errors for bar (client side).
    #[derive(Debug)]
    pub enum BarError {
        se(crate::types::SomeError),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BarError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::se(inner) => {
                    if f.alternate() {
                        write!(f, "OneMethodOptOut::bar failed with variant `se`: {:#}", inner)?;
                    } else {
                        write!(f, "OneMethodOptOut::bar failed with se(SomeError)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "OneMethodOptOut::bar failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "OneMethodOptOut::bar failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for BarError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::se(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::SomeError> for BarError {
        fn from(e: crate::types::SomeError) -> Self {
            Self::se(e)
        }
    }

    impl AsSomeError for BarError {
        fn as_some_error(&self) -> Option<&crate::types::SomeError> {
            match self {
                Self::se(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BarError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BarError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::one_method_opt_out::BarExn> for BarError {
        fn from(e: crate::services::one_method_opt_out::BarExn) -> Self {
            match e {
                crate::services::one_method_opt_out::BarExn::ApplicationException(aexn) =>
                    BarError::ApplicationException(aexn),
                crate::services::one_method_opt_out::BarExn::se(exn) =>
                    BarError::se(exn),
            }
        }
    }

    impl ::std::convert::From<BarError> for crate::services::one_method_opt_out::BarExn {
        fn from(err: BarError) -> Self {
            match err {
                BarError::se(err) => crate::services::one_method_opt_out::BarExn::se(err),
                BarError::ApplicationException(aexn) => crate::services::one_method_opt_out::BarExn::ApplicationException(aexn),
                BarError::ThriftError(err) => crate::services::one_method_opt_out::BarExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum BarReader {}

    impl ::fbthrift::help::DeserializeExn for BarReader {
        type Success = ::std::string::String;
        type Error = BarError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                ::fbthrift::Field::new("se", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::String, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::se(::fbthrift::Deserialize::read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "BarError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "BarError"),
                )
                .into(),
            )
        }
    }

}

#[doc(inline)]
#[allow(ambiguous_glob_reexports)]
pub use self::one_method_opt_out::*;

