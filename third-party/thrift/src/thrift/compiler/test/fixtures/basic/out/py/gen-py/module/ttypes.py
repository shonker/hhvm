#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass

def __EXPAND_THRIFT_SPEC(spec):
    next_id = 0
    for item in spec:
        if next_id >= 0 and item[0] < 0:
            next_id = item[0]
        if item[0] != next_id:
            for _ in range(next_id, item[0]):
                yield None
        yield item
        next_id = item[0] + 1

class ThriftEnumWrapper(int):
  def __new__(cls, enum_class, value):
    return super().__new__(cls, value)
  def __init__(self, enum_class, value):    self.enum_class = enum_class
  def __repr__(self):
    return self.enum_class.__name__ + '.' + self.enum_class._VALUES_TO_NAMES[self]

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'HackEnum', 'MyStruct', 'Containers', 'MyDataItem', 'MyUnion', 'MyException', 'ReservedKeyword', 'UnionToBeRenamed', 'MyEnumAlias', 'MyDataItemAlias']

class MyEnum:
  MyValue1 = 0
  MyValue2 = 1

  _VALUES_TO_NAMES = {
    0: "MyValue1",
    1: "MyValue2",
  }

  _NAMES_TO_VALUES = {
    "MyValue1": 0,
    "MyValue2": 1,
  }

class HackEnum:
  Value1 = 0
  Value2 = 1

  _VALUES_TO_NAMES = {
    0: "Value1",
    1: "Value2",
  }

  _NAMES_TO_VALUES = {
    "Value1": 0,
    "Value2": 1,
  }

class MyStruct:
  r"""
  Attributes:
   - MyIntField
   - MyStringField
   - MyDataField
   - myEnum
   - oneway
   - readonly
   - idempotent
   - floatSet
   - no_hack_codegen_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.MyStringField = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.MyDataField = MyDataItem()
          self.MyDataField.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.myEnum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.oneway = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.readonly = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.idempotent = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.floatSet = set()
          (_etype3, _size0) = iprot.readSetBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readFloat()
              self.floatSet.add(_elem5)
          else: 
            while iprot.peekSet():
              _elem6 = iprot.readFloat()
              self.floatSet.add(_elem6)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.no_hack_codegen_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 1)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    if self.MyStringField != None:
      oprot.writeFieldBegin('MyStringField', TType.STRING, 2)
      oprot.writeString(self.MyStringField.encode('utf-8')) if UTF8STRINGS and not isinstance(self.MyStringField, bytes) else oprot.writeString(self.MyStringField)
      oprot.writeFieldEnd()
    if self.MyDataField != None:
      oprot.writeFieldBegin('MyDataField', TType.STRUCT, 3)
      self.MyDataField.write(oprot)
      oprot.writeFieldEnd()
    if self.myEnum != None:
      oprot.writeFieldBegin('myEnum', TType.I32, 4)
      oprot.writeI32(self.myEnum)
      oprot.writeFieldEnd()
    if self.oneway != None:
      oprot.writeFieldBegin('oneway', TType.BOOL, 5)
      oprot.writeBool(self.oneway)
      oprot.writeFieldEnd()
    if self.readonly != None:
      oprot.writeFieldBegin('readonly', TType.BOOL, 6)
      oprot.writeBool(self.readonly)
      oprot.writeFieldEnd()
    if self.idempotent != None:
      oprot.writeFieldBegin('idempotent', TType.BOOL, 7)
      oprot.writeBool(self.idempotent)
      oprot.writeFieldEnd()
    if self.floatSet != None:
      oprot.writeFieldBegin('floatSet', TType.SET, 8)
      oprot.writeSetBegin(TType.FLOAT, len(self.floatSet))
      for iter7 in self.floatSet:
        oprot.writeFloat(iter7)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.no_hack_codegen_field != None:
      oprot.writeFieldBegin('no_hack_codegen_field', TType.STRING, 9)
      oprot.writeString(self.no_hack_codegen_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.no_hack_codegen_field, bytes) else oprot.writeString(self.no_hack_codegen_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'MyIntField' in json_obj and json_obj['MyIntField'] is not None:
      self.MyIntField = long(json_obj['MyIntField'])
    if 'MyStringField' in json_obj and json_obj['MyStringField'] is not None:
      self.MyStringField = json_obj['MyStringField']
    if 'MyDataField' in json_obj and json_obj['MyDataField'] is not None:
      self.MyDataField = MyDataItem()
      self.MyDataField.readFromJson(json_obj['MyDataField'], is_text=False, **kwargs)
    if 'myEnum' in json_obj and json_obj['myEnum'] is not None:
      self.myEnum = json_obj['myEnum']
      if not self.myEnum in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.myEnum
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      if wrap_enum_constants:
        self.myEnum = ThriftEnumWrapper(MyEnum, self.myEnum)
    if 'oneway' in json_obj and json_obj['oneway'] is not None:
      self.oneway = json_obj['oneway']
    if 'readonly' in json_obj and json_obj['readonly'] is not None:
      self.readonly = json_obj['readonly']
    if 'idempotent' in json_obj and json_obj['idempotent'] is not None:
      self.idempotent = json_obj['idempotent']
    if 'floatSet' in json_obj and json_obj['floatSet'] is not None:
      self.floatSet = set_cls()
      for _tmp_e8 in json_obj['floatSet']:
        self.floatSet.add(float(_tmp_e8))
    if 'no_hack_codegen_field' in json_obj and json_obj['no_hack_codegen_field'] is not None:
      self.no_hack_codegen_field = json_obj['no_hack_codegen_field']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    if self.MyStringField is not None:
      value = pprint.pformat(self.MyStringField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyStringField=%s' % (value))
    if self.MyDataField is not None:
      value = pprint.pformat(self.MyDataField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyDataField=%s' % (value))
    if self.myEnum is not None:
      value = pprint.pformat(self.myEnum, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    myEnum=%s' % (value))
    if self.oneway is not None:
      value = pprint.pformat(self.oneway, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    oneway=%s' % (value))
    if self.readonly is not None:
      value = pprint.pformat(self.readonly, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    readonly=%s' % (value))
    if self.idempotent is not None:
      value = pprint.pformat(self.idempotent, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    idempotent=%s' % (value))
    if self.floatSet is not None:
      value = pprint.pformat(self.floatSet, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatSet=%s' % (value))
    if self.no_hack_codegen_field is not None:
      value = pprint.pformat(self.no_hack_codegen_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    no_hack_codegen_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'MyIntField',
      'MyStringField',
      'MyDataField',
      'myEnum',
      'oneway',
      'readonly',
      'idempotent',
      'floatSet',
      'no_hack_codegen_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.basic.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.basic.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class Containers:
  r"""
  Attributes:
   - I32List
   - StringSet
   - StringToI64Map
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.I32List = []
          (_etype12, _size9) = iprot.readListBegin()
          if _size9 >= 0:
            for _i13 in range(_size9):
              _elem14 = iprot.readI32()
              self.I32List.append(_elem14)
          else: 
            while iprot.peekList():
              _elem15 = iprot.readI32()
              self.I32List.append(_elem15)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.StringSet = set()
          (_etype19, _size16) = iprot.readSetBegin()
          if _size16 >= 0:
            for _i20 in range(_size16):
              _elem21 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.StringSet.add(_elem21)
          else: 
            while iprot.peekSet():
              _elem22 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.StringSet.add(_elem22)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.StringToI64Map = {}
          (_ktype24, _vtype25, _size23 ) = iprot.readMapBegin() 
          if _size23 >= 0:
            for _i27 in range(_size23):
              _key28 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val29 = iprot.readI64()
              self.StringToI64Map[_key28] = _val29
          else: 
            while iprot.peekMap():
              _key30 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val31 = iprot.readI64()
              self.StringToI64Map[_key30] = _val31
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Containers')
    if self.I32List != None:
      oprot.writeFieldBegin('I32List', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.I32List))
      for iter32 in self.I32List:
        oprot.writeI32(iter32)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.StringSet != None:
      oprot.writeFieldBegin('StringSet', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.StringSet))
      for iter33 in self.StringSet:
        oprot.writeString(iter33.encode('utf-8')) if UTF8STRINGS and not isinstance(iter33, bytes) else oprot.writeString(iter33)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.StringToI64Map != None:
      oprot.writeFieldBegin('StringToI64Map', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.StringToI64Map))
      for kiter34,viter35 in self.StringToI64Map.items():
        oprot.writeString(kiter34.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter34, bytes) else oprot.writeString(kiter34)
        oprot.writeI64(viter35)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'I32List' in json_obj and json_obj['I32List'] is not None:
      self.I32List = []
      for _tmp_e36 in json_obj['I32List']:
        if _tmp_e36 > 0x7fffffff or _tmp_e36 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.I32List.append(_tmp_e36)
    if 'StringSet' in json_obj and json_obj['StringSet'] is not None:
      self.StringSet = set_cls()
      for _tmp_e37 in json_obj['StringSet']:
        self.StringSet.add(_tmp_e37)
    if 'StringToI64Map' in json_obj and json_obj['StringToI64Map'] is not None:
      self.StringToI64Map = dict_cls()
      for _tmp_k38, _tmp_v39 in json_obj['StringToI64Map'].items():
        _tmp_kp40 = _tmp_k38
        self.StringToI64Map[_tmp_kp40] = _tmp_v39

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.I32List is not None:
      value = pprint.pformat(self.I32List, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    I32List=%s' % (value))
    if self.StringSet is not None:
      value = pprint.pformat(self.StringSet, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    StringSet=%s' % (value))
    if self.StringToI64Map is not None:
      value = pprint.pformat(self.StringToI64Map, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    StringToI64Map=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'I32List',
      'StringSet',
      'StringToI64Map',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.basic.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Containers, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.basic.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Containers, self)

  def _to_py_deprecated(self):
    return self

class MyDataItem:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataItem')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.basic.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataItem, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.basic.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataItem, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  r"""
  Attributes:
   - myEnum
   - myStruct
   - myDataItem
   - floatSet
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  MYENUM = 1
  MYSTRUCT = 2
  MYDATAITEM = 3
  FLOATSET = 4
  
  @staticmethod
  def isUnion():
    return True

  def get_myEnum(self):
    assert self.field == 1
    return self.value

  def get_myStruct(self):
    assert self.field == 2
    return self.value

  def get_myDataItem(self):
    assert self.field == 3
    return self.value

  def get_floatSet(self):
    assert self.field == 4
    return self.value

  def set_myEnum(self, value):
    self.field = 1
    self.value = value

  def set_myStruct(self, value):
    self.field = 2
    self.value = value

  def set_myDataItem(self, value):
    self.field = 3
    self.value = value

  def set_floatSet(self, value):
    self.field = 4
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('myEnum', value)
    if self.field == 2:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('myStruct', value)
    if self.field == 3:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('myDataItem', value)
    if self.field == 4:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('floatSet', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_myEnum = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_myEnum(_fbthrift_myEnum)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          _fbthrift_myStruct = MyStruct()
          _fbthrift_myStruct.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_myStruct(_fbthrift_myStruct)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          _fbthrift_myDataItem = MyDataItem()
          _fbthrift_myDataItem.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_myDataItem(_fbthrift_myDataItem)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          _fbthrift_floatSet = set()
          (_etype44, _size41) = iprot.readSetBegin()
          if _size41 >= 0:
            for _i45 in range(_size41):
              _elem46 = iprot.readFloat()
              _fbthrift_floatSet.add(_elem46)
          else: 
            while iprot.peekSet():
              _elem47 = iprot.readFloat()
              _fbthrift_floatSet.add(_elem47)
          iprot.readSetEnd()
          assert self.field == 0 and self.value is None
          self.set_floatSet(_fbthrift_floatSet)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('myEnum', TType.I32, 1)
      myEnum = self.value
      oprot.writeI32(myEnum)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('myStruct', TType.STRUCT, 2)
      myStruct = self.value
      myStruct.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('myDataItem', TType.STRUCT, 3)
      myDataItem = self.value
      myDataItem.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('floatSet', TType.SET, 4)
      floatSet = self.value
      oprot.writeSetBegin(TType.FLOAT, len(floatSet))
      for iter48 in floatSet:
        oprot.writeFloat(iter48)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'myEnum' in obj:
      _fbthrift_myEnum = obj['myEnum']
      if not _fbthrift_myEnum in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % _fbthrift_myEnum
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      if wrap_enum_constants:
        _fbthrift_myEnum = ThriftEnumWrapper(MyEnum, _fbthrift_myEnum)
      self.set_myEnum(_fbthrift_myEnum)
    if 'myStruct' in obj:
      _fbthrift_myStruct = MyStruct()
      _fbthrift_myStruct.readFromJson(obj['myStruct'], is_text=False, **kwargs)
      self.set_myStruct(_fbthrift_myStruct)
    if 'myDataItem' in obj:
      _fbthrift_myDataItem = MyDataItem()
      _fbthrift_myDataItem.readFromJson(obj['myDataItem'], is_text=False, **kwargs)
      self.set_myDataItem(_fbthrift_myDataItem)
    if 'floatSet' in obj:
      _fbthrift_floatSet = set_cls()
      for _tmp_e49 in obj['floatSet']:
        _fbthrift_floatSet.add(float(_tmp_e49))
      self.set_floatSet(_fbthrift_floatSet)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.basic.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.basic.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyException(TException):
  r"""
  Attributes:
   - MyIntField
   - MyStringField
   - myStruct
   - myUnion
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.MyStringField = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.myStruct = MyStruct()
          self.myStruct.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.myUnion = MyUnion()
          self.myUnion.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyException')
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 1)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    if self.MyStringField != None:
      oprot.writeFieldBegin('MyStringField', TType.STRING, 2)
      oprot.writeString(self.MyStringField.encode('utf-8')) if UTF8STRINGS and not isinstance(self.MyStringField, bytes) else oprot.writeString(self.MyStringField)
      oprot.writeFieldEnd()
    if self.myStruct != None:
      oprot.writeFieldBegin('myStruct', TType.STRUCT, 3)
      self.myStruct.write(oprot)
      oprot.writeFieldEnd()
    if self.myUnion != None:
      oprot.writeFieldBegin('myUnion', TType.STRUCT, 4)
      self.myUnion.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'MyIntField' in json_obj and json_obj['MyIntField'] is not None:
      self.MyIntField = long(json_obj['MyIntField'])
    if 'MyStringField' in json_obj and json_obj['MyStringField'] is not None:
      self.MyStringField = json_obj['MyStringField']
    if 'myStruct' in json_obj and json_obj['myStruct'] is not None:
      self.myStruct = MyStruct()
      self.myStruct.readFromJson(json_obj['myStruct'], is_text=False, **kwargs)
    if 'myUnion' in json_obj and json_obj['myUnion'] is not None:
      self.myUnion = MyUnion()
      self.myUnion.readFromJson(json_obj['myUnion'], is_text=False, **kwargs)

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    if self.MyStringField is not None:
      value = pprint.pformat(self.MyStringField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyStringField=%s' % (value))
    if self.myStruct is not None:
      value = pprint.pformat(self.myStruct, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    myStruct=%s' % (value))
    if self.myUnion is not None:
      value = pprint.pformat(self.myUnion, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    myUnion=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'MyIntField',
      'MyStringField',
      'myStruct',
      'myUnion',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.basic.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyException, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.basic.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyException, self)

  def _to_py_deprecated(self):
    return self

class ReservedKeyword:
  r"""
  Attributes:
   - reserved_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.reserved_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ReservedKeyword')
    if self.reserved_field != None:
      oprot.writeFieldBegin('reserved_field', TType.I32, 1)
      oprot.writeI32(self.reserved_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'reserved_field' in json_obj and json_obj['reserved_field'] is not None:
      self.reserved_field = json_obj['reserved_field']
      if self.reserved_field > 0x7fffffff or self.reserved_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.reserved_field is not None:
      value = pprint.pformat(self.reserved_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    reserved_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'reserved_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.basic.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ReservedKeyword, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.basic.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ReservedKeyword, self)

  def _to_py_deprecated(self):
    return self

class UnionToBeRenamed(object):
  r"""
  Attributes:
   - reserved_field
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  RESERVED_FIELD = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_reserved_field(self):
    assert self.field == 1
    return self.value

  def set_reserved_field(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 15
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('reserved_field', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_reserved_field = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_reserved_field(_fbthrift_reserved_field)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('UnionToBeRenamed')
    if self.field == 1:
      oprot.writeFieldBegin('reserved_field', TType.I32, 1)
      reserved_field = self.value
      oprot.writeI32(reserved_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    kwargs_copy = dict(kwargs)
    relax_enum_validation = bool(kwargs_copy.pop('relax_enum_validation', False))
    set_cls = kwargs_copy.pop('custom_set_cls', set)
    dict_cls = kwargs_copy.pop('custom_dict_cls', dict)
    wrap_enum_constants = kwargs_copy.pop('wrap_enum_constants', False)
    if wrap_enum_constants and relax_enum_validation:
        raise ValueError(
            'wrap_enum_constants cannot be used together with relax_enum_validation'
        )
    if kwargs_copy:
        extra_kwargs = ', '.join(kwargs_copy.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'reserved_field' in obj:
      _fbthrift_reserved_field = obj['reserved_field']
      if _fbthrift_reserved_field > 0x7fffffff or _fbthrift_reserved_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_reserved_field(_fbthrift_reserved_field)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.basic.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.UnionToBeRenamed, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.basic.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.UnionToBeRenamed, self)

  def _to_py_deprecated(self):
    return self

MyEnumAlias = MyEnum
MyDataItemAlias = MyDataItem
all_structs.append(MyStruct)
MyStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'MyIntField', None, None, 2, ), # 1
  (2, TType.STRING, 'MyStringField', True, None, 2, ), # 2
  (3, TType.STRUCT, 'MyDataField', [MyDataItem, MyDataItem.thrift_spec, False], None, 2, ), # 3
  (4, TType.I32, 'myEnum', MyEnum, None, 2, ), # 4
  (5, TType.BOOL, 'oneway', None, None, 2, ), # 5
  (6, TType.BOOL, 'readonly', None, None, 2, ), # 6
  (7, TType.BOOL, 'idempotent', None, None, 2, ), # 7
  (8, TType.SET, 'floatSet', (TType.FLOAT,None), None, 2, ), # 8
  (9, TType.STRING, 'no_hack_codegen_field', True, None, 2, ), # 9
)))

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, MyIntField=None, MyStringField=None, MyDataField=None, myEnum=None, oneway=None, readonly=None, idempotent=None, floatSet=None, no_hack_codegen_field=None,):
  self.MyIntField = MyIntField
  self.MyStringField = MyStringField
  self.MyDataField = MyDataField
  self.myEnum = myEnum
  self.oneway = oneway
  self.readonly = readonly
  self.idempotent = idempotent
  self.floatSet = floatSet
  self.no_hack_codegen_field = no_hack_codegen_field

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('MyIntField', None)
  state.setdefault('MyStringField', None)
  state.setdefault('MyDataField', None)
  state.setdefault('myEnum', None)
  state.setdefault('oneway', None)
  state.setdefault('readonly', None)
  state.setdefault('idempotent', None)
  state.setdefault('floatSet', None)
  state.setdefault('no_hack_codegen_field', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(Containers)
Containers.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'I32List', (TType.I32,None), None, 2, ), # 1
  (2, TType.SET, 'StringSet', (TType.STRING,True), None, 2, ), # 2
  (3, TType.MAP, 'StringToI64Map', (TType.STRING,True,TType.I64,None), None, 2, ), # 3
)))

Containers.thrift_struct_annotations = {
}
Containers.thrift_field_annotations = {
}

def Containers__init__(self, I32List=None, StringSet=None, StringToI64Map=None,):
  self.I32List = I32List
  self.StringSet = StringSet
  self.StringToI64Map = StringToI64Map

Containers.__init__ = Containers__init__

def Containers__setstate__(self, state):
  state.setdefault('I32List', None)
  state.setdefault('StringSet', None)
  state.setdefault('StringToI64Map', None)
  self.__dict__ = state

Containers.__getstate__ = lambda self: self.__dict__.copy()
Containers.__setstate__ = Containers__setstate__

all_structs.append(MyDataItem)
MyDataItem.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

MyDataItem.thrift_struct_annotations = {
}
MyDataItem.thrift_field_annotations = {
}

all_structs.append(MyUnion)
MyUnion.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'myEnum', MyEnum, None, 2, ), # 1
  (2, TType.STRUCT, 'myStruct', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'myDataItem', [MyDataItem, MyDataItem.thrift_spec, False], None, 2, ), # 3
  (4, TType.SET, 'floatSet', (TType.FLOAT,None), None, 2, ), # 4
)))

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, myEnum=None, myStruct=None, myDataItem=None, floatSet=None,):
  self.field = 0
  self.value = None
  if myEnum is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = myEnum
  if myStruct is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = myStruct
  if myDataItem is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = myDataItem
  if floatSet is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = floatSet

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyException)
MyException.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'MyIntField', None, None, 2, ), # 1
  (2, TType.STRING, 'MyStringField', True, None, 2, ), # 2
  (3, TType.STRUCT, 'myStruct', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'myUnion', [MyUnion, MyUnion.thrift_spec, True], None, 2, ), # 4
)))

MyException.thrift_struct_annotations = {
}
MyException.thrift_field_annotations = {
}

def MyException__init__(self, MyIntField=None, MyStringField=None, myStruct=None, myUnion=None,):
  self.MyIntField = MyIntField
  self.MyStringField = MyStringField
  self.myStruct = myStruct
  self.myUnion = myUnion

MyException.__init__ = MyException__init__

def MyException__setstate__(self, state):
  state.setdefault('MyIntField', None)
  state.setdefault('MyStringField', None)
  state.setdefault('myStruct', None)
  state.setdefault('myUnion', None)
  self.__dict__ = state

MyException.__getstate__ = lambda self: self.__dict__.copy()
MyException.__setstate__ = MyException__setstate__

all_structs.append(ReservedKeyword)
ReservedKeyword.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'reserved_field', None, None, 2, ), # 1
)))

ReservedKeyword.thrift_struct_annotations = {
}
ReservedKeyword.thrift_field_annotations = {
}

def ReservedKeyword__init__(self, reserved_field=None,):
  self.reserved_field = reserved_field

ReservedKeyword.__init__ = ReservedKeyword__init__

def ReservedKeyword__setstate__(self, state):
  state.setdefault('reserved_field', None)
  self.__dict__ = state

ReservedKeyword.__getstate__ = lambda self: self.__dict__.copy()
ReservedKeyword.__setstate__ = ReservedKeyword__setstate__

all_structs.append(UnionToBeRenamed)
UnionToBeRenamed.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'reserved_field', None, None, 2, ), # 1
)))

UnionToBeRenamed.thrift_struct_annotations = {
}
UnionToBeRenamed.thrift_field_annotations = {
}

def UnionToBeRenamed__init__(self, reserved_field=None,):
  self.field = 0
  self.value = None
  if reserved_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = reserved_field

UnionToBeRenamed.__init__ = UnionToBeRenamed__init__

fix_spec(all_structs)
del all_structs
