// Autogenerated by Thrift for thrift/compiler/test/fixtures/types/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "fmt"
    "strings"

    included "included"
    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

var _ = included.GoUnusedProtection__
// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = strings.Split
var _ = thrift.ZERO


type TBinary = []byte

func NewTBinary() TBinary {
    return []byte("")
}

func WriteTBinary(item TBinary, p thrift.Format) error {
    if err := p.WriteBinary(item); err != nil {
    return err
}
    return nil
}

func ReadTBinary(p thrift.Format) (TBinary, error) {
    var decodeResult TBinary
    decodeErr := func() error {
        result, err := p.ReadBinary()
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type IntTypedef = int32

func NewIntTypedef() IntTypedef {
    return 0
}

func WriteIntTypedef(item IntTypedef, p thrift.Format) error {
    if err := p.WriteI32(item); err != nil {
    return err
}
    return nil
}

func ReadIntTypedef(p thrift.Format) (IntTypedef, error) {
    var decodeResult IntTypedef
    decodeErr := func() error {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type UintTypedef = IntTypedef

func NewUintTypedef() UintTypedef {
    return NewIntTypedef()
}

func WriteUintTypedef(item UintTypedef, p thrift.Format) error {
    err := WriteIntTypedef(item, p)
if err != nil {
    return err
}
    return nil
}

func ReadUintTypedef(p thrift.Format) (UintTypedef, error) {
    var decodeResult UintTypedef
    decodeErr := func() error {
        result, err := ReadIntTypedef(p)
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type SomeListOfTypeMap_2468 = included.SomeListOfTypeMap

func NewSomeListOfTypeMap_2468() SomeListOfTypeMap_2468 {
    return included.NewSomeListOfTypeMap()
}

func WriteSomeListOfTypeMap_2468(item SomeListOfTypeMap_2468, p thrift.Format) error {
    err := included.WriteSomeListOfTypeMap(item, p)
if err != nil {
    return err
}
    return nil
}

func ReadSomeListOfTypeMap_2468(p thrift.Format) (SomeListOfTypeMap_2468, error) {
    var decodeResult SomeListOfTypeMap_2468
    decodeErr := func() error {
        result, err := included.ReadSomeListOfTypeMap(p)
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type TBinary_8623 = TBinary

func NewTBinary_8623() TBinary_8623 {
    return NewTBinary()
}

func WriteTBinary_8623(item TBinary_8623, p thrift.Format) error {
    err := WriteTBinary(item, p)
if err != nil {
    return err
}
    return nil
}

func ReadTBinary_8623(p thrift.Format) (TBinary_8623, error) {
    var decodeResult TBinary_8623
    decodeErr := func() error {
        result, err := ReadTBinary(p)
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type I32_9314 = int32

func NewI32_9314() I32_9314 {
    return 0
}

func WriteI32_9314(item I32_9314, p thrift.Format) error {
    if err := p.WriteI32(item); err != nil {
    return err
}
    return nil
}

func ReadI32_9314(p thrift.Format) (I32_9314, error) {
    var decodeResult I32_9314
    decodeErr := func() error {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type ListI32_9187 = []int32

func NewListI32_9187() ListI32_9187 {
    return make([]int32, 0)
}

func WriteListI32_9187(item ListI32_9187, p thrift.Format) error {
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}
    return nil
}

func ReadListI32_9187(p thrift.Format) (ListI32_9187, error) {
    var decodeResult ListI32_9187
    decodeErr := func() error {
        _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type MapI32I32_9565 = map[int32]int32

func NewMapI32I32_9565() MapI32I32_9565 {
    return make(map[int32]int32)
}

func WriteMapI32I32_9565(item MapI32I32_9565, p thrift.Format) error {
    if err := p.WriteMapBegin(thrift.I32, thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}
    return nil
}

func ReadMapI32I32_9565(p thrift.Format) (MapI32I32_9565, error) {
    var decodeResult MapI32I32_9565
    decodeErr := func() error {
        _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]int32, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type MapI32String_1261 = map[int32]string

func NewMapI32String_1261() MapI32String_1261 {
    return make(map[int32]string)
}

func WriteMapI32String_1261(item MapI32String_1261, p thrift.Format) error {
    if err := p.WriteMapBegin(thrift.I32, thrift.STRING, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteString(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}
    return nil
}

func ReadMapI32String_1261(p thrift.Format) (MapI32String_1261, error) {
    var decodeResult MapI32String_1261
    decodeErr := func() error {
        _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]string, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value string
    {
        result, err := p.ReadString()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type SetI32_7070 = []int32

func NewSetI32_7070() SetI32_7070 {
    return make([]int32, 0)
}

func WriteSetI32_7070(item SetI32_7070, p thrift.Format) error {
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteSetEnd(); err != nil {
    return thrift.PrependError("error writing set end: ", err)
}
    return nil
}

func ReadSetI32_7070(p thrift.Format) (SetI32_7070, error) {
    var decodeResult SetI32_7070
    decodeErr := func() error {
        _ /* elemType */, size, err := p.ReadSetBegin()
if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
}

setResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    setResult = append(setResult, elem)
}

if err := p.ReadSetEnd(); err != nil {
    return thrift.PrependError("error reading set end: ", err)
}
result := setResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type SetI32_7194 = []int32

func NewSetI32_7194() SetI32_7194 {
    return make([]int32, 0)
}

func WriteSetI32_7194(item SetI32_7194, p thrift.Format) error {
    if err := p.WriteSetBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing set begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteSetEnd(); err != nil {
    return thrift.PrependError("error writing set end: ", err)
}
    return nil
}

func ReadSetI32_7194(p thrift.Format) (SetI32_7194, error) {
    var decodeResult SetI32_7194
    decodeErr := func() error {
        _ /* elemType */, size, err := p.ReadSetBegin()
if err != nil {
    return thrift.PrependError("error reading set begin: ", err)
}

setResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    setResult = append(setResult, elem)
}

if err := p.ReadSetEnd(); err != nil {
    return thrift.PrependError("error reading set end: ", err)
}
result := setResult
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type String_5252 = string

func NewString_5252() String_5252 {
    return ""
}

func WriteString_5252(item String_5252, p thrift.Format) error {
    if err := p.WriteString(item); err != nil {
    return err
}
    return nil
}

func ReadString_5252(p thrift.Format) (String_5252, error) {
    var decodeResult String_5252
    decodeErr := func() error {
        result, err := p.ReadString()
if err != nil {
    return err
}
        decodeResult = result
        return nil
    }()
    return decodeResult, decodeErr
}

type HasBitwiseOps int32

const (
    HasBitwiseOps_none HasBitwiseOps = 0
    HasBitwiseOps_zero HasBitwiseOps = 1
    HasBitwiseOps_one HasBitwiseOps = 2
    HasBitwiseOps_two HasBitwiseOps = 4
    HasBitwiseOps_three HasBitwiseOps = 8
)

// Enum value maps for HasBitwiseOps
var (
    HasBitwiseOpsToName = map[HasBitwiseOps]string {
        HasBitwiseOps_none: "none",
        HasBitwiseOps_zero: "zero",
        HasBitwiseOps_one: "one",
        HasBitwiseOps_two: "two",
        HasBitwiseOps_three: "three",
    }

    HasBitwiseOpsToValue = map[string]HasBitwiseOps {
        "none": HasBitwiseOps_none,
        "zero": HasBitwiseOps_zero,
        "one": HasBitwiseOps_one,
        "two": HasBitwiseOps_two,
        "three": HasBitwiseOps_three,
    }
)

func (x HasBitwiseOps) String() string {
    if v, ok := HasBitwiseOpsToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x HasBitwiseOps) Ptr() *HasBitwiseOps {
    return &x
}

// Deprecated: Use HasBitwiseOpsToValue instead (e.g. `x, ok := HasBitwiseOpsToValue["name"]`).
func HasBitwiseOpsFromString(s string) (HasBitwiseOps, error) {
    if v, ok := HasBitwiseOpsToValue[s]; ok {
        return v, nil
    }
    return HasBitwiseOps(0), fmt.Errorf("not a valid HasBitwiseOps string")
}


type IsUnscoped int32

const (
    IsUnscoped_hello IsUnscoped = 0
    IsUnscoped_world IsUnscoped = 1
)

// Enum value maps for IsUnscoped
var (
    IsUnscopedToName = map[IsUnscoped]string {
        IsUnscoped_hello: "hello",
        IsUnscoped_world: "world",
    }

    IsUnscopedToValue = map[string]IsUnscoped {
        "hello": IsUnscoped_hello,
        "world": IsUnscoped_world,
    }
)

func (x IsUnscoped) String() string {
    if v, ok := IsUnscopedToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x IsUnscoped) Ptr() *IsUnscoped {
    return &x
}

// Deprecated: Use IsUnscopedToValue instead (e.g. `x, ok := IsUnscopedToValue["name"]`).
func IsUnscopedFromString(s string) (IsUnscoped, error) {
    if v, ok := IsUnscopedToValue[s]; ok {
        return v, nil
    }
    return IsUnscoped(0), fmt.Errorf("not a valid IsUnscoped string")
}


type MyForwardRefEnum int32

const (
    MyForwardRefEnum_ZERO MyForwardRefEnum = 0
    MyForwardRefEnum_NONZERO MyForwardRefEnum = 12
)

// Enum value maps for MyForwardRefEnum
var (
    MyForwardRefEnumToName = map[MyForwardRefEnum]string {
        MyForwardRefEnum_ZERO: "ZERO",
        MyForwardRefEnum_NONZERO: "NONZERO",
    }

    MyForwardRefEnumToValue = map[string]MyForwardRefEnum {
        "ZERO": MyForwardRefEnum_ZERO,
        "NONZERO": MyForwardRefEnum_NONZERO,
    }
)

func (x MyForwardRefEnum) String() string {
    if v, ok := MyForwardRefEnumToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x MyForwardRefEnum) Ptr() *MyForwardRefEnum {
    return &x
}

// Deprecated: Use MyForwardRefEnumToValue instead (e.g. `x, ok := MyForwardRefEnumToValue["name"]`).
func MyForwardRefEnumFromString(s string) (MyForwardRefEnum, error) {
    if v, ok := MyForwardRefEnumToValue[s]; ok {
        return v, nil
    }
    return MyForwardRefEnum(0), fmt.Errorf("not a valid MyForwardRefEnum string")
}


type EmptyStruct struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*EmptyStruct)(nil)

func NewEmptyStruct() *EmptyStruct {
    return (&EmptyStruct{})
}



func (x *EmptyStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("empty_struct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *EmptyStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *EmptyStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("EmptyStruct({")
    sb.WriteString("})")

    return sb.String()
}

type DecoratedStruct struct {
    Field string `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*DecoratedStruct)(nil)

func NewDecoratedStruct() *DecoratedStruct {
    return (&DecoratedStruct{}).
        SetFieldNonCompat("")
}

func (x *DecoratedStruct) GetField() string {
    return x.Field
}

func (x *DecoratedStruct) SetFieldNonCompat(value string) *DecoratedStruct {
    x.Field = value
    return x
}

func (x *DecoratedStruct) SetField(value string) *DecoratedStruct {
    x.Field = value
    return x
}

func (x *DecoratedStruct) writeField1(p thrift.Format) error {  // Field
    if err := p.WriteFieldBegin("field", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DecoratedStruct) readField1(p thrift.Format) error {  // Field
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.Field = result
    return nil
}

func (x *DecoratedStruct) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}



func (x *DecoratedStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("decorated_struct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DecoratedStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DecoratedStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DecoratedStruct({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type ContainerStruct struct {
    FieldB []int32 `thrift:"fieldB,2" json:"fieldB" db:"fieldB"`
    FieldC []int32 `thrift:"fieldC,3" json:"fieldC" db:"fieldC"`
    FieldD []int32 `thrift:"fieldD,4" json:"fieldD" db:"fieldD"`
    FieldE []int32 `thrift:"fieldE,5" json:"fieldE" db:"fieldE"`
    FieldF SetI32_7194 `thrift:"fieldF,6" json:"fieldF" db:"fieldF"`
    FieldG MapI32String_1261 `thrift:"fieldG,7" json:"fieldG" db:"fieldG"`
    FieldH included.SomeMap `thrift:"fieldH,8" json:"fieldH" db:"fieldH"`
    FieldA []int32 `thrift:"fieldA,12" json:"fieldA" db:"fieldA"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ContainerStruct)(nil)

func NewContainerStruct() *ContainerStruct {
    return (&ContainerStruct{}).
        SetFieldBNonCompat(make([]int32, 0)).
        SetFieldCNonCompat(make([]int32, 0)).
        SetFieldDNonCompat(make([]int32, 0)).
        SetFieldENonCompat(make([]int32, 0)).
        SetFieldFNonCompat(NewSetI32_7194()).
        SetFieldGNonCompat(NewMapI32String_1261()).
        SetFieldHNonCompat(included.NewSomeMap()).
        SetFieldANonCompat(make([]int32, 0))
}

func (x *ContainerStruct) GetFieldB() []int32 {
    if !x.IsSetFieldB() {
        return make([]int32, 0)
    }

    return x.FieldB
}

func (x *ContainerStruct) GetFieldC() []int32 {
    if !x.IsSetFieldC() {
        return make([]int32, 0)
    }

    return x.FieldC
}

func (x *ContainerStruct) GetFieldD() []int32 {
    if !x.IsSetFieldD() {
        return make([]int32, 0)
    }

    return x.FieldD
}

func (x *ContainerStruct) GetFieldE() []int32 {
    if !x.IsSetFieldE() {
        return make([]int32, 0)
    }

    return x.FieldE
}

func (x *ContainerStruct) GetFieldF() SetI32_7194 {
    if !x.IsSetFieldF() {
        return NewSetI32_7194()
    }

    return x.FieldF
}

func (x *ContainerStruct) GetFieldG() MapI32String_1261 {
    if !x.IsSetFieldG() {
        return NewMapI32String_1261()
    }

    return x.FieldG
}

func (x *ContainerStruct) GetFieldH() included.SomeMap {
    if !x.IsSetFieldH() {
        return included.NewSomeMap()
    }

    return x.FieldH
}

func (x *ContainerStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
        return make([]int32, 0)
    }

    return x.FieldA
}

func (x *ContainerStruct) SetFieldBNonCompat(value []int32) *ContainerStruct {
    x.FieldB = value
    return x
}

func (x *ContainerStruct) SetFieldB(value []int32) *ContainerStruct {
    x.FieldB = value
    return x
}

func (x *ContainerStruct) SetFieldCNonCompat(value []int32) *ContainerStruct {
    x.FieldC = value
    return x
}

func (x *ContainerStruct) SetFieldC(value []int32) *ContainerStruct {
    x.FieldC = value
    return x
}

func (x *ContainerStruct) SetFieldDNonCompat(value []int32) *ContainerStruct {
    x.FieldD = value
    return x
}

func (x *ContainerStruct) SetFieldD(value []int32) *ContainerStruct {
    x.FieldD = value
    return x
}

func (x *ContainerStruct) SetFieldENonCompat(value []int32) *ContainerStruct {
    x.FieldE = value
    return x
}

func (x *ContainerStruct) SetFieldE(value []int32) *ContainerStruct {
    x.FieldE = value
    return x
}

func (x *ContainerStruct) SetFieldFNonCompat(value SetI32_7194) *ContainerStruct {
    x.FieldF = value
    return x
}

func (x *ContainerStruct) SetFieldF(value SetI32_7194) *ContainerStruct {
    x.FieldF = value
    return x
}

func (x *ContainerStruct) SetFieldGNonCompat(value MapI32String_1261) *ContainerStruct {
    x.FieldG = value
    return x
}

func (x *ContainerStruct) SetFieldG(value MapI32String_1261) *ContainerStruct {
    x.FieldG = value
    return x
}

func (x *ContainerStruct) SetFieldHNonCompat(value included.SomeMap) *ContainerStruct {
    x.FieldH = value
    return x
}

func (x *ContainerStruct) SetFieldH(value included.SomeMap) *ContainerStruct {
    x.FieldH = value
    return x
}

func (x *ContainerStruct) SetFieldANonCompat(value []int32) *ContainerStruct {
    x.FieldA = value
    return x
}

func (x *ContainerStruct) SetFieldA(value []int32) *ContainerStruct {
    x.FieldA = value
    return x
}

func (x *ContainerStruct) IsSetFieldB() bool {
    return x != nil && x.FieldB != nil
}

func (x *ContainerStruct) IsSetFieldC() bool {
    return x != nil && x.FieldC != nil
}

func (x *ContainerStruct) IsSetFieldD() bool {
    return x != nil && x.FieldD != nil
}

func (x *ContainerStruct) IsSetFieldE() bool {
    return x != nil && x.FieldE != nil
}

func (x *ContainerStruct) IsSetFieldF() bool {
    return x != nil && x.FieldF != nil
}

func (x *ContainerStruct) IsSetFieldG() bool {
    return x != nil && x.FieldG != nil
}

func (x *ContainerStruct) IsSetFieldH() bool {
    return x != nil && x.FieldH != nil
}

func (x *ContainerStruct) IsSetFieldA() bool {
    return x != nil && x.FieldA != nil
}

func (x *ContainerStruct) writeField2(p thrift.Format) error {  // FieldB
    if err := p.WriteFieldBegin("fieldB", thrift.LIST, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldB
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField3(p thrift.Format) error {  // FieldC
    if err := p.WriteFieldBegin("fieldC", thrift.LIST, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldC
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField4(p thrift.Format) error {  // FieldD
    if err := p.WriteFieldBegin("fieldD", thrift.LIST, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldD
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField5(p thrift.Format) error {  // FieldE
    if err := p.WriteFieldBegin("fieldE", thrift.LIST, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldE
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField6(p thrift.Format) error {  // FieldF
    if err := p.WriteFieldBegin("fieldF", thrift.SET, 6); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldF
    err := WriteSetI32_7194(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField7(p thrift.Format) error {  // FieldG
    if err := p.WriteFieldBegin("fieldG", thrift.MAP, 7); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldG
    err := WriteMapI32String_1261(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField8(p thrift.Format) error {  // FieldH
    if err := p.WriteFieldBegin("fieldH", thrift.MAP, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldH
    err := included.WriteSomeMap(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) writeField12(p thrift.Format) error {  // FieldA
    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 12); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldA
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) readField2(p thrift.Format) error {  // FieldB
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.FieldB = result
    return nil
}

func (x *ContainerStruct) readField3(p thrift.Format) error {  // FieldC
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.FieldC = result
    return nil
}

func (x *ContainerStruct) readField4(p thrift.Format) error {  // FieldD
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.FieldD = result
    return nil
}

func (x *ContainerStruct) readField5(p thrift.Format) error {  // FieldE
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.FieldE = result
    return nil
}

func (x *ContainerStruct) readField6(p thrift.Format) error {  // FieldF
    result, err := ReadSetI32_7194(p)
if err != nil {
    return err
}

    x.FieldF = result
    return nil
}

func (x *ContainerStruct) readField7(p thrift.Format) error {  // FieldG
    result, err := ReadMapI32String_1261(p)
if err != nil {
    return err
}

    x.FieldG = result
    return nil
}

func (x *ContainerStruct) readField8(p thrift.Format) error {  // FieldH
    result, err := included.ReadSomeMap(p)
if err != nil {
    return err
}

    x.FieldH = result
    return nil
}

func (x *ContainerStruct) readField12(p thrift.Format) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.FieldA = result
    return nil
}

func (x *ContainerStruct) toString2() string {  // FieldB
    return fmt.Sprintf("%v", x.FieldB)
}

func (x *ContainerStruct) toString3() string {  // FieldC
    return fmt.Sprintf("%v", x.FieldC)
}

func (x *ContainerStruct) toString4() string {  // FieldD
    return fmt.Sprintf("%v", x.FieldD)
}

func (x *ContainerStruct) toString5() string {  // FieldE
    return fmt.Sprintf("%v", x.FieldE)
}

func (x *ContainerStruct) toString6() string {  // FieldF
    return fmt.Sprintf("%v", x.FieldF)
}

func (x *ContainerStruct) toString7() string {  // FieldG
    return fmt.Sprintf("%v", x.FieldG)
}

func (x *ContainerStruct) toString8() string {  // FieldH
    return fmt.Sprintf("%v", x.FieldH)
}

func (x *ContainerStruct) toString12() string {  // FieldA
    return fmt.Sprintf("%v", x.FieldA)
}



func (x *ContainerStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("ContainerStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := x.writeField6(p); err != nil {
        return err
    }

    if err := x.writeField7(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := x.writeField12(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ContainerStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 2 && wireType == thrift.Type(thrift.LIST)):  // fieldB
            if err := x.readField2(p); err != nil {
                return err
            }
        case (id == 3 && wireType == thrift.Type(thrift.LIST)):  // fieldC
            if err := x.readField3(p); err != nil {
                return err
            }
        case (id == 4 && wireType == thrift.Type(thrift.LIST)):  // fieldD
            if err := x.readField4(p); err != nil {
                return err
            }
        case (id == 5 && wireType == thrift.Type(thrift.LIST)):  // fieldE
            if err := x.readField5(p); err != nil {
                return err
            }
        case (id == 6 && wireType == thrift.Type(thrift.SET)):  // fieldF
            if err := x.readField6(p); err != nil {
                return err
            }
        case (id == 7 && wireType == thrift.Type(thrift.MAP)):  // fieldG
            if err := x.readField7(p); err != nil {
                return err
            }
        case (id == 8 && wireType == thrift.Type(thrift.MAP)):  // fieldH
            if err := x.readField8(p); err != nil {
                return err
            }
        case (id == 12 && wireType == thrift.Type(thrift.LIST)):  // fieldA
            if err := x.readField12(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ContainerStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ContainerStruct({")
    sb.WriteString(fmt.Sprintf("FieldB:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("FieldC:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("FieldD:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("FieldE:%s ", x.toString5()))
    sb.WriteString(fmt.Sprintf("FieldF:%s ", x.toString6()))
    sb.WriteString(fmt.Sprintf("FieldG:%s ", x.toString7()))
    sb.WriteString(fmt.Sprintf("FieldH:%s ", x.toString8()))
    sb.WriteString(fmt.Sprintf("FieldA:%s", x.toString12()))
    sb.WriteString("})")

    return sb.String()
}

type CppTypeStruct struct {
    FieldA []int32 `thrift:"fieldA,1" json:"fieldA" db:"fieldA"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*CppTypeStruct)(nil)

func NewCppTypeStruct() *CppTypeStruct {
    return (&CppTypeStruct{}).
        SetFieldANonCompat(make([]int32, 0))
}

func (x *CppTypeStruct) GetFieldA() []int32 {
    if !x.IsSetFieldA() {
        return make([]int32, 0)
    }

    return x.FieldA
}

func (x *CppTypeStruct) SetFieldANonCompat(value []int32) *CppTypeStruct {
    x.FieldA = value
    return x
}

func (x *CppTypeStruct) SetFieldA(value []int32) *CppTypeStruct {
    x.FieldA = value
    return x
}

func (x *CppTypeStruct) IsSetFieldA() bool {
    return x != nil && x.FieldA != nil
}

func (x *CppTypeStruct) writeField1(p thrift.Format) error {  // FieldA
    if err := p.WriteFieldBegin("fieldA", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.FieldA
    if err := p.WriteListBegin(thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CppTypeStruct) readField1(p thrift.Format) error {  // FieldA
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int32, 0, size)
for i := 0; i < size; i++ {
    var elem int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.FieldA = result
    return nil
}

func (x *CppTypeStruct) toString1() string {  // FieldA
    return fmt.Sprintf("%v", x.FieldA)
}



func (x *CppTypeStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("CppTypeStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CppTypeStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.LIST)):  // fieldA
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CppTypeStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CppTypeStruct({")
    sb.WriteString(fmt.Sprintf("FieldA:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type VirtualStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*VirtualStruct)(nil)

func NewVirtualStruct() *VirtualStruct {
    return (&VirtualStruct{}).
        SetMyIntFieldNonCompat(0)
}

func (x *VirtualStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *VirtualStruct) SetMyIntFieldNonCompat(value int64) *VirtualStruct {
    x.MyIntField = value
    return x
}

func (x *VirtualStruct) SetMyIntField(value int64) *VirtualStruct {
    x.MyIntField = value
    return x
}

func (x *VirtualStruct) writeField1(p thrift.Format) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.MyIntField
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *VirtualStruct) readField1(p thrift.Format) error {  // MyIntField
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.MyIntField = result
    return nil
}

func (x *VirtualStruct) toString1() string {  // MyIntField
    return fmt.Sprintf("%v", x.MyIntField)
}



func (x *VirtualStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("VirtualStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *VirtualStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I64)):  // MyIntField
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *VirtualStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("VirtualStruct({")
    sb.WriteString(fmt.Sprintf("MyIntField:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type MyStructWithForwardRefEnum struct {
    A MyForwardRefEnum `thrift:"a,1" json:"a" db:"a"`
    B MyForwardRefEnum `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MyStructWithForwardRefEnum)(nil)

func NewMyStructWithForwardRefEnum() *MyStructWithForwardRefEnum {
    return (&MyStructWithForwardRefEnum{}).
        SetANonCompat(
              MyForwardRefEnum_NONZERO,
          ).
        SetBNonCompat(
              MyForwardRefEnum_NONZERO,
          )
}

func (x *MyStructWithForwardRefEnum) GetA() MyForwardRefEnum {
    return x.A
}

func (x *MyStructWithForwardRefEnum) GetB() MyForwardRefEnum {
    return x.B
}

func (x *MyStructWithForwardRefEnum) SetANonCompat(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.A = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetA(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.A = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetBNonCompat(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.B = value
    return x
}

func (x *MyStructWithForwardRefEnum) SetB(value MyForwardRefEnum) *MyStructWithForwardRefEnum {
    x.B = value
    return x
}

func (x *MyStructWithForwardRefEnum) writeField1(p thrift.Format) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.A
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) writeField2(p thrift.Format) error {  // B
    if err := p.WriteFieldBegin("b", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.B
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) readField1(p thrift.Format) error {  // A
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := MyForwardRefEnum(enumResult)

    x.A = result
    return nil
}

func (x *MyStructWithForwardRefEnum) readField2(p thrift.Format) error {  // B
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := MyForwardRefEnum(enumResult)

    x.B = result
    return nil
}

func (x *MyStructWithForwardRefEnum) toString1() string {  // A
    return fmt.Sprintf("%v", x.A)
}

func (x *MyStructWithForwardRefEnum) toString2() string {  // B
    return fmt.Sprintf("%v", x.B)
}



func (x *MyStructWithForwardRefEnum) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("MyStructWithForwardRefEnum"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyStructWithForwardRefEnum) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // a
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.I32)):  // b
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyStructWithForwardRefEnum) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyStructWithForwardRefEnum({")
    sb.WriteString(fmt.Sprintf("A:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("B:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type TrivialNumeric struct {
    A int32 `thrift:"a,1" json:"a" db:"a"`
    B bool `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*TrivialNumeric)(nil)

func NewTrivialNumeric() *TrivialNumeric {
    return (&TrivialNumeric{}).
        SetANonCompat(0).
        SetBNonCompat(false)
}

func (x *TrivialNumeric) GetA() int32 {
    return x.A
}

func (x *TrivialNumeric) GetB() bool {
    return x.B
}

func (x *TrivialNumeric) SetANonCompat(value int32) *TrivialNumeric {
    x.A = value
    return x
}

func (x *TrivialNumeric) SetA(value int32) *TrivialNumeric {
    x.A = value
    return x
}

func (x *TrivialNumeric) SetBNonCompat(value bool) *TrivialNumeric {
    x.B = value
    return x
}

func (x *TrivialNumeric) SetB(value bool) *TrivialNumeric {
    x.B = value
    return x
}

func (x *TrivialNumeric) writeField1(p thrift.Format) error {  // A
    if err := p.WriteFieldBegin("a", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.A
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) writeField2(p thrift.Format) error {  // B
    if err := p.WriteFieldBegin("b", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.B
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) readField1(p thrift.Format) error {  // A
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.A = result
    return nil
}

func (x *TrivialNumeric) readField2(p thrift.Format) error {  // B
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.B = result
    return nil
}

func (x *TrivialNumeric) toString1() string {  // A
    return fmt.Sprintf("%v", x.A)
}

func (x *TrivialNumeric) toString2() string {  // B
    return fmt.Sprintf("%v", x.B)
}



func (x *TrivialNumeric) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("TrivialNumeric"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TrivialNumeric) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // a
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.BOOL)):  // b
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *TrivialNumeric) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("TrivialNumeric({")
    sb.WriteString(fmt.Sprintf("A:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("B:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type TrivialNestedWithDefault struct {
    Z int32 `thrift:"z,1" json:"z" db:"z"`
    N *TrivialNumeric `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*TrivialNestedWithDefault)(nil)

func NewTrivialNestedWithDefault() *TrivialNestedWithDefault {
    return (&TrivialNestedWithDefault{}).
        SetZNonCompat(4).
        SetNNonCompat(
              *NewTrivialNumeric().
    SetANonCompat(3).
    SetBNonCompat(true),
          )
}

func (x *TrivialNestedWithDefault) GetZ() int32 {
    return x.Z
}

func (x *TrivialNestedWithDefault) GetN() *TrivialNumeric {
    if !x.IsSetN() {
        return nil
    }

    return x.N
}

func (x *TrivialNestedWithDefault) SetZNonCompat(value int32) *TrivialNestedWithDefault {
    x.Z = value
    return x
}

func (x *TrivialNestedWithDefault) SetZ(value int32) *TrivialNestedWithDefault {
    x.Z = value
    return x
}

func (x *TrivialNestedWithDefault) SetNNonCompat(value TrivialNumeric) *TrivialNestedWithDefault {
    x.N = &value
    return x
}

func (x *TrivialNestedWithDefault) SetN(value *TrivialNumeric) *TrivialNestedWithDefault {
    x.N = value
    return x
}

func (x *TrivialNestedWithDefault) IsSetN() bool {
    return x != nil && x.N != nil
}

func (x *TrivialNestedWithDefault) writeField1(p thrift.Format) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Z
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) writeField2(p thrift.Format) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.N
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) readField1(p thrift.Format) error {  // Z
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.Z = result
    return nil
}

func (x *TrivialNestedWithDefault) readField2(p thrift.Format) error {  // N
    result := *NewTrivialNumeric()
err := result.Read(p)
if err != nil {
    return err
}

    x.N = &result
    return nil
}

func (x *TrivialNestedWithDefault) toString1() string {  // Z
    return fmt.Sprintf("%v", x.Z)
}

func (x *TrivialNestedWithDefault) toString2() string {  // N
    return fmt.Sprintf("%v", x.N)
}

// Deprecated: Use NewTrivialNestedWithDefault().GetN() instead.
func (x *TrivialNestedWithDefault) DefaultGetN() *TrivialNumeric {
    if !x.IsSetN() {
        return NewTrivialNumeric()
    }
    return x.N
}



func (x *TrivialNestedWithDefault) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("TrivialNestedWithDefault"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TrivialNestedWithDefault) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // z
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.STRUCT)):  // n
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *TrivialNestedWithDefault) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("TrivialNestedWithDefault({")
    sb.WriteString(fmt.Sprintf("Z:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("N:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ComplexString struct {
    A string `thrift:"a,1" json:"a" db:"a"`
    B map[string]int32 `thrift:"b,2" json:"b" db:"b"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ComplexString)(nil)

func NewComplexString() *ComplexString {
    return (&ComplexString{}).
        SetANonCompat("").
        SetBNonCompat(make(map[string]int32))
}

func (x *ComplexString) GetA() string {
    return x.A
}

func (x *ComplexString) GetB() map[string]int32 {
    if !x.IsSetB() {
        return make(map[string]int32)
    }

    return x.B
}

func (x *ComplexString) SetANonCompat(value string) *ComplexString {
    x.A = value
    return x
}

func (x *ComplexString) SetA(value string) *ComplexString {
    x.A = value
    return x
}

func (x *ComplexString) SetBNonCompat(value map[string]int32) *ComplexString {
    x.B = value
    return x
}

func (x *ComplexString) SetB(value map[string]int32) *ComplexString {
    x.B = value
    return x
}

func (x *ComplexString) IsSetB() bool {
    return x != nil && x.B != nil
}

func (x *ComplexString) writeField1(p thrift.Format) error {  // A
    if err := p.WriteFieldBegin("a", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.A
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) writeField2(p thrift.Format) error {  // B
    if err := p.WriteFieldBegin("b", thrift.MAP, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.B
    if err := p.WriteMapBegin(thrift.STRING, thrift.I32, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteString(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := p.WriteI32(item); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) readField1(p thrift.Format) error {  // A
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.A = result
    return nil
}

func (x *ComplexString) readField2(p thrift.Format) error {  // B
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[string]int32, size)
for i := 0; i < size; i++ {
    var key string
    {
        result, err := p.ReadString()
if err != nil {
    return err
}
        key = result
    }

    var value int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        value = result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.B = result
    return nil
}

func (x *ComplexString) toString1() string {  // A
    return fmt.Sprintf("%v", x.A)
}

func (x *ComplexString) toString2() string {  // B
    return fmt.Sprintf("%v", x.B)
}



func (x *ComplexString) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("ComplexString"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ComplexString) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // a
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.MAP)):  // b
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ComplexString) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ComplexString({")
    sb.WriteString(fmt.Sprintf("A:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("B:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ComplexNestedWithDefault struct {
    Z string `thrift:"z,1" json:"z" db:"z"`
    N *ComplexString `thrift:"n,2" json:"n" db:"n"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ComplexNestedWithDefault)(nil)

func NewComplexNestedWithDefault() *ComplexNestedWithDefault {
    return (&ComplexNestedWithDefault{}).
        SetZNonCompat("4").
        SetNNonCompat(
              *NewComplexString().
    SetANonCompat("3").
    SetBNonCompat(
        map[string]int32{
    "a": 3,
},
    ),
          )
}

func (x *ComplexNestedWithDefault) GetZ() string {
    return x.Z
}

func (x *ComplexNestedWithDefault) GetN() *ComplexString {
    if !x.IsSetN() {
        return nil
    }

    return x.N
}

func (x *ComplexNestedWithDefault) SetZNonCompat(value string) *ComplexNestedWithDefault {
    x.Z = value
    return x
}

func (x *ComplexNestedWithDefault) SetZ(value string) *ComplexNestedWithDefault {
    x.Z = value
    return x
}

func (x *ComplexNestedWithDefault) SetNNonCompat(value ComplexString) *ComplexNestedWithDefault {
    x.N = &value
    return x
}

func (x *ComplexNestedWithDefault) SetN(value *ComplexString) *ComplexNestedWithDefault {
    x.N = value
    return x
}

func (x *ComplexNestedWithDefault) IsSetN() bool {
    return x != nil && x.N != nil
}

func (x *ComplexNestedWithDefault) writeField1(p thrift.Format) error {  // Z
    if err := p.WriteFieldBegin("z", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Z
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) writeField2(p thrift.Format) error {  // N
    if !x.IsSetN() {
        return nil
    }

    if err := p.WriteFieldBegin("n", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.N
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) readField1(p thrift.Format) error {  // Z
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.Z = result
    return nil
}

func (x *ComplexNestedWithDefault) readField2(p thrift.Format) error {  // N
    result := *NewComplexString()
err := result.Read(p)
if err != nil {
    return err
}

    x.N = &result
    return nil
}

func (x *ComplexNestedWithDefault) toString1() string {  // Z
    return fmt.Sprintf("%v", x.Z)
}

func (x *ComplexNestedWithDefault) toString2() string {  // N
    return fmt.Sprintf("%v", x.N)
}

// Deprecated: Use NewComplexNestedWithDefault().GetN() instead.
func (x *ComplexNestedWithDefault) DefaultGetN() *ComplexString {
    if !x.IsSetN() {
        return NewComplexString()
    }
    return x.N
}



func (x *ComplexNestedWithDefault) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("ComplexNestedWithDefault"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ComplexNestedWithDefault) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // z
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.STRUCT)):  // n
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ComplexNestedWithDefault) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ComplexNestedWithDefault({")
    sb.WriteString(fmt.Sprintf("Z:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("N:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type MinPadding struct {
    Small int8 `thrift:"small,1,required" json:"small" db:"small"`
    Big int64 `thrift:"big,2,required" json:"big" db:"big"`
    Medium int16 `thrift:"medium,3,required" json:"medium" db:"medium"`
    Biggish int32 `thrift:"biggish,4,required" json:"biggish" db:"biggish"`
    Tiny int8 `thrift:"tiny,5,required" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MinPadding)(nil)

func NewMinPadding() *MinPadding {
    return (&MinPadding{}).
        SetSmallNonCompat(0).
        SetBigNonCompat(0).
        SetMediumNonCompat(0).
        SetBiggishNonCompat(0).
        SetTinyNonCompat(0)
}

func (x *MinPadding) GetSmall() int8 {
    return x.Small
}

func (x *MinPadding) GetBig() int64 {
    return x.Big
}

func (x *MinPadding) GetMedium() int16 {
    return x.Medium
}

func (x *MinPadding) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPadding) GetTiny() int8 {
    return x.Tiny
}

func (x *MinPadding) SetSmallNonCompat(value int8) *MinPadding {
    x.Small = value
    return x
}

func (x *MinPadding) SetSmall(value int8) *MinPadding {
    x.Small = value
    return x
}

func (x *MinPadding) SetBigNonCompat(value int64) *MinPadding {
    x.Big = value
    return x
}

func (x *MinPadding) SetBig(value int64) *MinPadding {
    x.Big = value
    return x
}

func (x *MinPadding) SetMediumNonCompat(value int16) *MinPadding {
    x.Medium = value
    return x
}

func (x *MinPadding) SetMedium(value int16) *MinPadding {
    x.Medium = value
    return x
}

func (x *MinPadding) SetBiggishNonCompat(value int32) *MinPadding {
    x.Biggish = value
    return x
}

func (x *MinPadding) SetBiggish(value int32) *MinPadding {
    x.Biggish = value
    return x
}

func (x *MinPadding) SetTinyNonCompat(value int8) *MinPadding {
    x.Tiny = value
    return x
}

func (x *MinPadding) SetTiny(value int8) *MinPadding {
    x.Tiny = value
    return x
}

func (x *MinPadding) writeField1(p thrift.Format) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Small
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField2(p thrift.Format) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Big
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField3(p thrift.Format) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Medium
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField4(p thrift.Format) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Biggish
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) writeField5(p thrift.Format) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Tiny
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) readField1(p thrift.Format) error {  // Small
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.Small = result
    return nil
}

func (x *MinPadding) readField2(p thrift.Format) error {  // Big
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.Big = result
    return nil
}

func (x *MinPadding) readField3(p thrift.Format) error {  // Medium
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.Medium = result
    return nil
}

func (x *MinPadding) readField4(p thrift.Format) error {  // Biggish
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.Biggish = result
    return nil
}

func (x *MinPadding) readField5(p thrift.Format) error {  // Tiny
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.Tiny = result
    return nil
}

func (x *MinPadding) toString1() string {  // Small
    return fmt.Sprintf("%v", x.Small)
}

func (x *MinPadding) toString2() string {  // Big
    return fmt.Sprintf("%v", x.Big)
}

func (x *MinPadding) toString3() string {  // Medium
    return fmt.Sprintf("%v", x.Medium)
}

func (x *MinPadding) toString4() string {  // Biggish
    return fmt.Sprintf("%v", x.Biggish)
}

func (x *MinPadding) toString5() string {  // Tiny
    return fmt.Sprintf("%v", x.Tiny)
}



func (x *MinPadding) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("MinPadding"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinPadding) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.BYTE)):  // small
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.I64)):  // big
            if err := x.readField2(p); err != nil {
                return err
            }
        case (id == 3 && wireType == thrift.Type(thrift.I16)):  // medium
            if err := x.readField3(p); err != nil {
                return err
            }
        case (id == 4 && wireType == thrift.Type(thrift.I32)):  // biggish
            if err := x.readField4(p); err != nil {
                return err
            }
        case (id == 5 && wireType == thrift.Type(thrift.BYTE)):  // tiny
            if err := x.readField5(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MinPadding) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MinPadding({")
    sb.WriteString(fmt.Sprintf("Small:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Big:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Medium:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("Biggish:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("Tiny:%s", x.toString5()))
    sb.WriteString("})")

    return sb.String()
}

type MinPaddingWithCustomType struct {
    Small int8 `thrift:"small,1" json:"small" db:"small"`
    Big int64 `thrift:"big,2" json:"big" db:"big"`
    Medium int16 `thrift:"medium,3" json:"medium" db:"medium"`
    Biggish int32 `thrift:"biggish,4" json:"biggish" db:"biggish"`
    Tiny int8 `thrift:"tiny,5" json:"tiny" db:"tiny"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MinPaddingWithCustomType)(nil)

func NewMinPaddingWithCustomType() *MinPaddingWithCustomType {
    return (&MinPaddingWithCustomType{}).
        SetSmallNonCompat(0).
        SetBigNonCompat(0).
        SetMediumNonCompat(0).
        SetBiggishNonCompat(0).
        SetTinyNonCompat(0)
}

func (x *MinPaddingWithCustomType) GetSmall() int8 {
    return x.Small
}

func (x *MinPaddingWithCustomType) GetBig() int64 {
    return x.Big
}

func (x *MinPaddingWithCustomType) GetMedium() int16 {
    return x.Medium
}

func (x *MinPaddingWithCustomType) GetBiggish() int32 {
    return x.Biggish
}

func (x *MinPaddingWithCustomType) GetTiny() int8 {
    return x.Tiny
}

func (x *MinPaddingWithCustomType) SetSmallNonCompat(value int8) *MinPaddingWithCustomType {
    x.Small = value
    return x
}

func (x *MinPaddingWithCustomType) SetSmall(value int8) *MinPaddingWithCustomType {
    x.Small = value
    return x
}

func (x *MinPaddingWithCustomType) SetBigNonCompat(value int64) *MinPaddingWithCustomType {
    x.Big = value
    return x
}

func (x *MinPaddingWithCustomType) SetBig(value int64) *MinPaddingWithCustomType {
    x.Big = value
    return x
}

func (x *MinPaddingWithCustomType) SetMediumNonCompat(value int16) *MinPaddingWithCustomType {
    x.Medium = value
    return x
}

func (x *MinPaddingWithCustomType) SetMedium(value int16) *MinPaddingWithCustomType {
    x.Medium = value
    return x
}

func (x *MinPaddingWithCustomType) SetBiggishNonCompat(value int32) *MinPaddingWithCustomType {
    x.Biggish = value
    return x
}

func (x *MinPaddingWithCustomType) SetBiggish(value int32) *MinPaddingWithCustomType {
    x.Biggish = value
    return x
}

func (x *MinPaddingWithCustomType) SetTinyNonCompat(value int8) *MinPaddingWithCustomType {
    x.Tiny = value
    return x
}

func (x *MinPaddingWithCustomType) SetTiny(value int8) *MinPaddingWithCustomType {
    x.Tiny = value
    return x
}

func (x *MinPaddingWithCustomType) writeField1(p thrift.Format) error {  // Small
    if err := p.WriteFieldBegin("small", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Small
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField2(p thrift.Format) error {  // Big
    if err := p.WriteFieldBegin("big", thrift.I64, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Big
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField3(p thrift.Format) error {  // Medium
    if err := p.WriteFieldBegin("medium", thrift.I16, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Medium
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField4(p thrift.Format) error {  // Biggish
    if err := p.WriteFieldBegin("biggish", thrift.I32, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Biggish
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) writeField5(p thrift.Format) error {  // Tiny
    if err := p.WriteFieldBegin("tiny", thrift.BYTE, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Tiny
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) readField1(p thrift.Format) error {  // Small
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.Small = result
    return nil
}

func (x *MinPaddingWithCustomType) readField2(p thrift.Format) error {  // Big
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.Big = result
    return nil
}

func (x *MinPaddingWithCustomType) readField3(p thrift.Format) error {  // Medium
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.Medium = result
    return nil
}

func (x *MinPaddingWithCustomType) readField4(p thrift.Format) error {  // Biggish
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.Biggish = result
    return nil
}

func (x *MinPaddingWithCustomType) readField5(p thrift.Format) error {  // Tiny
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.Tiny = result
    return nil
}

func (x *MinPaddingWithCustomType) toString1() string {  // Small
    return fmt.Sprintf("%v", x.Small)
}

func (x *MinPaddingWithCustomType) toString2() string {  // Big
    return fmt.Sprintf("%v", x.Big)
}

func (x *MinPaddingWithCustomType) toString3() string {  // Medium
    return fmt.Sprintf("%v", x.Medium)
}

func (x *MinPaddingWithCustomType) toString4() string {  // Biggish
    return fmt.Sprintf("%v", x.Biggish)
}

func (x *MinPaddingWithCustomType) toString5() string {  // Tiny
    return fmt.Sprintf("%v", x.Tiny)
}



func (x *MinPaddingWithCustomType) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("MinPaddingWithCustomType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinPaddingWithCustomType) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.BYTE)):  // small
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.I64)):  // big
            if err := x.readField2(p); err != nil {
                return err
            }
        case (id == 3 && wireType == thrift.Type(thrift.I16)):  // medium
            if err := x.readField3(p); err != nil {
                return err
            }
        case (id == 4 && wireType == thrift.Type(thrift.I32)):  // biggish
            if err := x.readField4(p); err != nil {
                return err
            }
        case (id == 5 && wireType == thrift.Type(thrift.BYTE)):  // tiny
            if err := x.readField5(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MinPaddingWithCustomType) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MinPaddingWithCustomType({")
    sb.WriteString(fmt.Sprintf("Small:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Big:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Medium:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("Biggish:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("Tiny:%s", x.toString5()))
    sb.WriteString("})")

    return sb.String()
}

type MyStruct struct {
    MyIntField int64 `thrift:"MyIntField,1" json:"MyIntField" db:"MyIntField"`
    MyStringField string `thrift:"MyStringField,2" json:"MyStringField" db:"MyStringField"`
    MajorVer int64 `thrift:"majorVer,3" json:"majorVer" db:"majorVer"`
    Data *MyDataItem `thrift:"data,4" json:"data" db:"data"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*MyStruct)(nil)

func NewMyStruct() *MyStruct {
    return (&MyStruct{}).
        SetMyIntFieldNonCompat(0).
        SetMyStringFieldNonCompat("").
        SetMajorVerNonCompat(0).
        SetDataNonCompat(*NewMyDataItem())
}

func (x *MyStruct) GetMyIntField() int64 {
    return x.MyIntField
}

func (x *MyStruct) GetMyStringField() string {
    return x.MyStringField
}

func (x *MyStruct) GetMajorVer() int64 {
    return x.MajorVer
}

func (x *MyStruct) GetData() *MyDataItem {
    if !x.IsSetData() {
        return nil
    }

    return x.Data
}

func (x *MyStruct) SetMyIntFieldNonCompat(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyIntField(value int64) *MyStruct {
    x.MyIntField = value
    return x
}

func (x *MyStruct) SetMyStringFieldNonCompat(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMyStringField(value string) *MyStruct {
    x.MyStringField = value
    return x
}

func (x *MyStruct) SetMajorVerNonCompat(value int64) *MyStruct {
    x.MajorVer = value
    return x
}

func (x *MyStruct) SetMajorVer(value int64) *MyStruct {
    x.MajorVer = value
    return x
}

func (x *MyStruct) SetDataNonCompat(value MyDataItem) *MyStruct {
    x.Data = &value
    return x
}

func (x *MyStruct) SetData(value *MyDataItem) *MyStruct {
    x.Data = value
    return x
}

func (x *MyStruct) IsSetData() bool {
    return x != nil && x.Data != nil
}

func (x *MyStruct) writeField1(p thrift.Format) error {  // MyIntField
    if err := p.WriteFieldBegin("MyIntField", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.MyIntField
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField2(p thrift.Format) error {  // MyStringField
    if err := p.WriteFieldBegin("MyStringField", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.MyStringField
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField3(p thrift.Format) error {  // MajorVer
    if err := p.WriteFieldBegin("majorVer", thrift.I64, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.MajorVer
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) writeField4(p thrift.Format) error {  // Data
    if !x.IsSetData() {
        return nil
    }

    if err := p.WriteFieldBegin("data", thrift.STRUCT, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Data
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) readField1(p thrift.Format) error {  // MyIntField
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.MyIntField = result
    return nil
}

func (x *MyStruct) readField2(p thrift.Format) error {  // MyStringField
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.MyStringField = result
    return nil
}

func (x *MyStruct) readField3(p thrift.Format) error {  // MajorVer
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.MajorVer = result
    return nil
}

func (x *MyStruct) readField4(p thrift.Format) error {  // Data
    result := *NewMyDataItem()
err := result.Read(p)
if err != nil {
    return err
}

    x.Data = &result
    return nil
}

func (x *MyStruct) toString1() string {  // MyIntField
    return fmt.Sprintf("%v", x.MyIntField)
}

func (x *MyStruct) toString2() string {  // MyStringField
    return fmt.Sprintf("%v", x.MyStringField)
}

func (x *MyStruct) toString3() string {  // MajorVer
    return fmt.Sprintf("%v", x.MajorVer)
}

func (x *MyStruct) toString4() string {  // Data
    return fmt.Sprintf("%v", x.Data)
}

// Deprecated: Use NewMyStruct().GetData() instead.
func (x *MyStruct) DefaultGetData() *MyDataItem {
    if !x.IsSetData() {
        return NewMyDataItem()
    }
    return x.Data
}



func (x *MyStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("MyStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I64)):  // MyIntField
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.STRING)):  // MyStringField
            if err := x.readField2(p); err != nil {
                return err
            }
        case (id == 3 && wireType == thrift.Type(thrift.I64)):  // majorVer
            if err := x.readField3(p); err != nil {
                return err
            }
        case (id == 4 && wireType == thrift.Type(thrift.STRUCT)):  // data
            if err := x.readField4(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyStruct({")
    sb.WriteString(fmt.Sprintf("MyIntField:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("MyStringField:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("MajorVer:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("Data:%s", x.toString4()))
    sb.WriteString("})")

    return sb.String()
}

type MyDataItem struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*MyDataItem)(nil)

func NewMyDataItem() *MyDataItem {
    return (&MyDataItem{})
}



func (x *MyDataItem) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("MyDataItem"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MyDataItem) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MyDataItem) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MyDataItem({")
    sb.WriteString("})")

    return sb.String()
}

type Renaming struct {
    Foo int64 `thrift:"foo,1" json:"foo" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Renaming)(nil)

func NewRenaming() *Renaming {
    return (&Renaming{}).
        SetFooNonCompat(0)
}

func (x *Renaming) GetFoo() int64 {
    return x.Foo
}

func (x *Renaming) SetFooNonCompat(value int64) *Renaming {
    x.Foo = value
    return x
}

func (x *Renaming) SetFoo(value int64) *Renaming {
    x.Foo = value
    return x
}

func (x *Renaming) writeField1(p thrift.Format) error {  // Foo
    if err := p.WriteFieldBegin("foo", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Foo
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Renaming) readField1(p thrift.Format) error {  // Foo
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.Foo = result
    return nil
}

func (x *Renaming) toString1() string {  // Foo
    return fmt.Sprintf("%v", x.Foo)
}



func (x *Renaming) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("Renaming"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Renaming) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I64)):  // foo
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Renaming) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Renaming({")
    sb.WriteString(fmt.Sprintf("Foo:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type AnnotatedTypes struct {
    BinaryField TBinary_8623 `thrift:"binary_field,1" json:"binary_field" db:"binary_field"`
    ListField SomeListOfTypeMap_2468 `thrift:"list_field,2" json:"list_field" db:"list_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AnnotatedTypes)(nil)

func NewAnnotatedTypes() *AnnotatedTypes {
    return (&AnnotatedTypes{}).
        SetBinaryFieldNonCompat(NewTBinary_8623()).
        SetListFieldNonCompat(NewSomeListOfTypeMap_2468())
}

func (x *AnnotatedTypes) GetBinaryField() TBinary_8623 {
    if !x.IsSetBinaryField() {
        return NewTBinary_8623()
    }

    return x.BinaryField
}

func (x *AnnotatedTypes) GetListField() SomeListOfTypeMap_2468 {
    if !x.IsSetListField() {
        return NewSomeListOfTypeMap_2468()
    }

    return x.ListField
}

func (x *AnnotatedTypes) SetBinaryFieldNonCompat(value TBinary_8623) *AnnotatedTypes {
    x.BinaryField = value
    return x
}

func (x *AnnotatedTypes) SetBinaryField(value TBinary_8623) *AnnotatedTypes {
    x.BinaryField = value
    return x
}

func (x *AnnotatedTypes) SetListFieldNonCompat(value SomeListOfTypeMap_2468) *AnnotatedTypes {
    x.ListField = value
    return x
}

func (x *AnnotatedTypes) SetListField(value SomeListOfTypeMap_2468) *AnnotatedTypes {
    x.ListField = value
    return x
}

func (x *AnnotatedTypes) IsSetBinaryField() bool {
    return x != nil && x.BinaryField != nil
}

func (x *AnnotatedTypes) IsSetListField() bool {
    return x != nil && x.ListField != nil
}

func (x *AnnotatedTypes) writeField1(p thrift.Format) error {  // BinaryField
    if err := p.WriteFieldBegin("binary_field", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.BinaryField
    err := WriteTBinary_8623(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) writeField2(p thrift.Format) error {  // ListField
    if err := p.WriteFieldBegin("list_field", thrift.LIST, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.ListField
    err := WriteSomeListOfTypeMap_2468(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) readField1(p thrift.Format) error {  // BinaryField
    result, err := ReadTBinary_8623(p)
if err != nil {
    return err
}

    x.BinaryField = result
    return nil
}

func (x *AnnotatedTypes) readField2(p thrift.Format) error {  // ListField
    result, err := ReadSomeListOfTypeMap_2468(p)
if err != nil {
    return err
}

    x.ListField = result
    return nil
}

func (x *AnnotatedTypes) toString1() string {  // BinaryField
    return fmt.Sprintf("%v", x.BinaryField)
}

func (x *AnnotatedTypes) toString2() string {  // ListField
    return fmt.Sprintf("%v", x.ListField)
}



func (x *AnnotatedTypes) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("AnnotatedTypes"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AnnotatedTypes) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // binary_field
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.LIST)):  // list_field
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AnnotatedTypes) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AnnotatedTypes({")
    sb.WriteString(fmt.Sprintf("BinaryField:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("ListField:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ForwardUsageRoot struct {
    ForwardUsageStruct *ForwardUsageStruct `thrift:"ForwardUsageStruct,1,optional" json:"ForwardUsageStruct,omitempty" db:"ForwardUsageStruct"`
    ForwardUsageByRef *ForwardUsageByRef `thrift:"ForwardUsageByRef,2,optional" json:"ForwardUsageByRef,omitempty" db:"ForwardUsageByRef"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ForwardUsageRoot)(nil)

func NewForwardUsageRoot() *ForwardUsageRoot {
    return (&ForwardUsageRoot{})
}

func (x *ForwardUsageRoot) GetForwardUsageStruct() *ForwardUsageStruct {
    if !x.IsSetForwardUsageStruct() {
        return nil
    }

    return x.ForwardUsageStruct
}

func (x *ForwardUsageRoot) GetForwardUsageByRef() *ForwardUsageByRef {
    if !x.IsSetForwardUsageByRef() {
        return nil
    }

    return x.ForwardUsageByRef
}

func (x *ForwardUsageRoot) SetForwardUsageStructNonCompat(value ForwardUsageStruct) *ForwardUsageRoot {
    x.ForwardUsageStruct = &value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageStruct(value *ForwardUsageStruct) *ForwardUsageRoot {
    x.ForwardUsageStruct = value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageByRefNonCompat(value ForwardUsageByRef) *ForwardUsageRoot {
    x.ForwardUsageByRef = &value
    return x
}

func (x *ForwardUsageRoot) SetForwardUsageByRef(value *ForwardUsageByRef) *ForwardUsageRoot {
    x.ForwardUsageByRef = value
    return x
}

func (x *ForwardUsageRoot) IsSetForwardUsageStruct() bool {
    return x != nil && x.ForwardUsageStruct != nil
}

func (x *ForwardUsageRoot) IsSetForwardUsageByRef() bool {
    return x != nil && x.ForwardUsageByRef != nil
}

func (x *ForwardUsageRoot) writeField1(p thrift.Format) error {  // ForwardUsageStruct
    if !x.IsSetForwardUsageStruct() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageStruct", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.ForwardUsageStruct
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) writeField2(p thrift.Format) error {  // ForwardUsageByRef
    if !x.IsSetForwardUsageByRef() {
        return nil
    }

    if err := p.WriteFieldBegin("ForwardUsageByRef", thrift.STRUCT, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.ForwardUsageByRef
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) readField1(p thrift.Format) error {  // ForwardUsageStruct
    result := *NewForwardUsageStruct()
err := result.Read(p)
if err != nil {
    return err
}

    x.ForwardUsageStruct = &result
    return nil
}

func (x *ForwardUsageRoot) readField2(p thrift.Format) error {  // ForwardUsageByRef
    result := *NewForwardUsageByRef()
err := result.Read(p)
if err != nil {
    return err
}

    x.ForwardUsageByRef = &result
    return nil
}

func (x *ForwardUsageRoot) toString1() string {  // ForwardUsageStruct
    return fmt.Sprintf("%v", x.ForwardUsageStruct)
}

func (x *ForwardUsageRoot) toString2() string {  // ForwardUsageByRef
    return fmt.Sprintf("%v", x.ForwardUsageByRef)
}

// Deprecated: Use NewForwardUsageRoot().GetForwardUsageStruct() instead.
func (x *ForwardUsageRoot) DefaultGetForwardUsageStruct() *ForwardUsageStruct {
    if !x.IsSetForwardUsageStruct() {
        return NewForwardUsageStruct()
    }
    return x.ForwardUsageStruct
}

// Deprecated: Use NewForwardUsageRoot().GetForwardUsageByRef() instead.
func (x *ForwardUsageRoot) DefaultGetForwardUsageByRef() *ForwardUsageByRef {
    if !x.IsSetForwardUsageByRef() {
        return NewForwardUsageByRef()
    }
    return x.ForwardUsageByRef
}



func (x *ForwardUsageRoot) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("ForwardUsageRoot"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageRoot) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRUCT)):  // ForwardUsageStruct
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.STRUCT)):  // ForwardUsageByRef
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ForwardUsageRoot) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ForwardUsageRoot({")
    sb.WriteString(fmt.Sprintf("ForwardUsageStruct:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("ForwardUsageByRef:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type ForwardUsageStruct struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ForwardUsageStruct)(nil)

func NewForwardUsageStruct() *ForwardUsageStruct {
    return (&ForwardUsageStruct{})
}

func (x *ForwardUsageStruct) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return nil
    }

    return x.Foo
}

func (x *ForwardUsageStruct) SetFooNonCompat(value ForwardUsageRoot) *ForwardUsageStruct {
    x.Foo = &value
    return x
}

func (x *ForwardUsageStruct) SetFoo(value *ForwardUsageRoot) *ForwardUsageStruct {
    x.Foo = value
    return x
}

func (x *ForwardUsageStruct) IsSetFoo() bool {
    return x != nil && x.Foo != nil
}

func (x *ForwardUsageStruct) writeField1(p thrift.Format) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Foo
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageStruct) readField1(p thrift.Format) error {  // Foo
    result := *NewForwardUsageRoot()
err := result.Read(p)
if err != nil {
    return err
}

    x.Foo = &result
    return nil
}

func (x *ForwardUsageStruct) toString1() string {  // Foo
    return fmt.Sprintf("%v", x.Foo)
}

// Deprecated: Use NewForwardUsageStruct().GetFoo() instead.
func (x *ForwardUsageStruct) DefaultGetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return NewForwardUsageRoot()
    }
    return x.Foo
}



func (x *ForwardUsageStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("ForwardUsageStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRUCT)):  // foo
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ForwardUsageStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ForwardUsageStruct({")
    sb.WriteString(fmt.Sprintf("Foo:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type ForwardUsageByRef struct {
    Foo *ForwardUsageRoot `thrift:"foo,1,optional" json:"foo,omitempty" db:"foo"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*ForwardUsageByRef)(nil)

func NewForwardUsageByRef() *ForwardUsageByRef {
    return (&ForwardUsageByRef{})
}

func (x *ForwardUsageByRef) GetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return nil
    }

    return x.Foo
}

func (x *ForwardUsageByRef) SetFooNonCompat(value ForwardUsageRoot) *ForwardUsageByRef {
    x.Foo = &value
    return x
}

func (x *ForwardUsageByRef) SetFoo(value *ForwardUsageRoot) *ForwardUsageByRef {
    x.Foo = value
    return x
}

func (x *ForwardUsageByRef) IsSetFoo() bool {
    return x != nil && x.Foo != nil
}

func (x *ForwardUsageByRef) writeField1(p thrift.Format) error {  // Foo
    if !x.IsSetFoo() {
        return nil
    }

    if err := p.WriteFieldBegin("foo", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Foo
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageByRef) readField1(p thrift.Format) error {  // Foo
    result := *NewForwardUsageRoot()
err := result.Read(p)
if err != nil {
    return err
}

    x.Foo = &result
    return nil
}

func (x *ForwardUsageByRef) toString1() string {  // Foo
    return fmt.Sprintf("%v", x.Foo)
}

// Deprecated: Use NewForwardUsageByRef().GetFoo() instead.
func (x *ForwardUsageByRef) DefaultGetFoo() *ForwardUsageRoot {
    if !x.IsSetFoo() {
        return NewForwardUsageRoot()
    }
    return x.Foo
}



func (x *ForwardUsageByRef) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("ForwardUsageByRef"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ForwardUsageByRef) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRUCT)):  // foo
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ForwardUsageByRef) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ForwardUsageByRef({")
    sb.WriteString(fmt.Sprintf("Foo:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type IncompleteMap struct {
    Field map[int32]*IncompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteMap)(nil)

func NewIncompleteMap() *IncompleteMap {
    return (&IncompleteMap{})
}

func (x *IncompleteMap) GetField() map[int32]*IncompleteMapDep {
    if !x.IsSetField() {
        return make(map[int32]*IncompleteMapDep)
    }

    return x.Field
}

func (x *IncompleteMap) SetFieldNonCompat(value map[int32]*IncompleteMapDep) *IncompleteMap {
    x.Field = value
    return x
}

func (x *IncompleteMap) SetField(value map[int32]*IncompleteMapDep) *IncompleteMap {
    x.Field = value
    return x
}

func (x *IncompleteMap) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *IncompleteMap) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMap) readField1(p thrift.Format) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]*IncompleteMapDep, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value *IncompleteMapDep
    {
        result := *NewIncompleteMapDep()
err := result.Read(p)
if err != nil {
    return err
}
        value = &result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.Field = result
    return nil
}

func (x *IncompleteMap) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}



func (x *IncompleteMap) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("IncompleteMap"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMap) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.MAP)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteMap) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteMap({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type IncompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteMapDep)(nil)

func NewIncompleteMapDep() *IncompleteMapDep {
    return (&IncompleteMapDep{})
}



func (x *IncompleteMapDep) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("IncompleteMapDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteMapDep) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteMapDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteMapDep({")
    sb.WriteString("})")

    return sb.String()
}

type CompleteMap struct {
    Field map[int32]*CompleteMapDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteMap)(nil)

func NewCompleteMap() *CompleteMap {
    return (&CompleteMap{})
}

func (x *CompleteMap) GetField() map[int32]*CompleteMapDep {
    if !x.IsSetField() {
        return make(map[int32]*CompleteMapDep)
    }

    return x.Field
}

func (x *CompleteMap) SetFieldNonCompat(value map[int32]*CompleteMapDep) *CompleteMap {
    x.Field = value
    return x
}

func (x *CompleteMap) SetField(value map[int32]*CompleteMapDep) *CompleteMap {
    x.Field = value
    return x
}

func (x *CompleteMap) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *CompleteMap) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.MAP, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := p.WriteMapBegin(thrift.I32, thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
}
for k, v := range item {
    {
        item := k
        if err := p.WriteI32(item); err != nil {
    return err
}
    }

    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteMapEnd(); err != nil {
    return thrift.PrependError("error writing map end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CompleteMap) readField1(p thrift.Format) error {  // Field
    _ /* keyType */, _ /* valueType */, size, err := p.ReadMapBegin()
if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
}

mapResult := make(map[int32]*CompleteMapDep, size)
for i := 0; i < size; i++ {
    var key int32
    {
        result, err := p.ReadI32()
if err != nil {
    return err
}
        key = result
    }

    var value *CompleteMapDep
    {
        result := *NewCompleteMapDep()
err := result.Read(p)
if err != nil {
    return err
}
        value = &result
    }

    mapResult[key] = value
}

if err := p.ReadMapEnd(); err != nil {
    return thrift.PrependError("error reading map end: ", err)
}
result := mapResult

    x.Field = result
    return nil
}

func (x *CompleteMap) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}



func (x *CompleteMap) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("CompleteMap"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteMap) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.MAP)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteMap) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteMap({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type CompleteMapDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteMapDep)(nil)

func NewCompleteMapDep() *CompleteMapDep {
    return (&CompleteMapDep{})
}



func (x *CompleteMapDep) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("CompleteMapDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteMapDep) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteMapDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteMapDep({")
    sb.WriteString("})")

    return sb.String()
}

type IncompleteList struct {
    Field []*IncompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteList)(nil)

func NewIncompleteList() *IncompleteList {
    return (&IncompleteList{})
}

func (x *IncompleteList) GetField() []*IncompleteListDep {
    if !x.IsSetField() {
        return make([]*IncompleteListDep, 0)
    }

    return x.Field
}

func (x *IncompleteList) SetFieldNonCompat(value []*IncompleteListDep) *IncompleteList {
    x.Field = value
    return x
}

func (x *IncompleteList) SetField(value []*IncompleteListDep) *IncompleteList {
    x.Field = value
    return x
}

func (x *IncompleteList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *IncompleteList) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *IncompleteList) readField1(p thrift.Format) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*IncompleteListDep, 0, size)
for i := 0; i < size; i++ {
    var elem IncompleteListDep
    {
        result := *NewIncompleteListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.Field = result
    return nil
}

func (x *IncompleteList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}



func (x *IncompleteList) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("IncompleteList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteList) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.LIST)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type IncompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*IncompleteListDep)(nil)

func NewIncompleteListDep() *IncompleteListDep {
    return (&IncompleteListDep{})
}



func (x *IncompleteListDep) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("IncompleteListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *IncompleteListDep) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *IncompleteListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("IncompleteListDep({")
    sb.WriteString("})")

    return sb.String()
}

type CompleteList struct {
    Field []*CompleteListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteList)(nil)

func NewCompleteList() *CompleteList {
    return (&CompleteList{})
}

func (x *CompleteList) GetField() []*CompleteListDep {
    if !x.IsSetField() {
        return make([]*CompleteListDep, 0)
    }

    return x.Field
}

func (x *CompleteList) SetFieldNonCompat(value []*CompleteListDep) *CompleteList {
    x.Field = value
    return x
}

func (x *CompleteList) SetField(value []*CompleteListDep) *CompleteList {
    x.Field = value
    return x
}

func (x *CompleteList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *CompleteList) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *CompleteList) readField1(p thrift.Format) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*CompleteListDep, 0, size)
for i := 0; i < size; i++ {
    var elem CompleteListDep
    {
        result := *NewCompleteListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.Field = result
    return nil
}

func (x *CompleteList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}



func (x *CompleteList) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("CompleteList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteList) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.LIST)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type CompleteListDep struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*CompleteListDep)(nil)

func NewCompleteListDep() *CompleteListDep {
    return (&CompleteListDep{})
}



func (x *CompleteListDep) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("CompleteListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *CompleteListDep) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *CompleteListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("CompleteListDep({")
    sb.WriteString("})")

    return sb.String()
}

type AdaptedList struct {
    Field []*AdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AdaptedList)(nil)

func NewAdaptedList() *AdaptedList {
    return (&AdaptedList{})
}

func (x *AdaptedList) GetField() []*AdaptedListDep {
    if !x.IsSetField() {
        return make([]*AdaptedListDep, 0)
    }

    return x.Field
}

func (x *AdaptedList) SetFieldNonCompat(value []*AdaptedListDep) *AdaptedList {
    x.Field = value
    return x
}

func (x *AdaptedList) SetField(value []*AdaptedListDep) *AdaptedList {
    x.Field = value
    return x
}

func (x *AdaptedList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *AdaptedList) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AdaptedList) readField1(p thrift.Format) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*AdaptedListDep, 0, size)
for i := 0; i < size; i++ {
    var elem AdaptedListDep
    {
        result := *NewAdaptedListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.Field = result
    return nil
}

func (x *AdaptedList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}



func (x *AdaptedList) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("AdaptedList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AdaptedList) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.LIST)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AdaptedList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AdaptedList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type AdaptedListDep struct {
    Field *AdaptedList `thrift:"field,1" json:"field" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AdaptedListDep)(nil)

func NewAdaptedListDep() *AdaptedListDep {
    return (&AdaptedListDep{}).
        SetFieldNonCompat(*NewAdaptedList())
}

func (x *AdaptedListDep) GetField() *AdaptedList {
    if !x.IsSetField() {
        return nil
    }

    return x.Field
}

func (x *AdaptedListDep) SetFieldNonCompat(value AdaptedList) *AdaptedListDep {
    x.Field = &value
    return x
}

func (x *AdaptedListDep) SetField(value *AdaptedList) *AdaptedListDep {
    x.Field = value
    return x
}

func (x *AdaptedListDep) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *AdaptedListDep) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.STRUCT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := item.Write(p); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AdaptedListDep) readField1(p thrift.Format) error {  // Field
    result := *NewAdaptedList()
err := result.Read(p)
if err != nil {
    return err
}

    x.Field = &result
    return nil
}

func (x *AdaptedListDep) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}

// Deprecated: Use NewAdaptedListDep().GetField() instead.
func (x *AdaptedListDep) DefaultGetField() *AdaptedList {
    if !x.IsSetField() {
        return NewAdaptedList()
    }
    return x.Field
}



func (x *AdaptedListDep) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("AdaptedListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AdaptedListDep) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRUCT)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AdaptedListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AdaptedListDep({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type DependentAdaptedList struct {
    Field []*DependentAdaptedListDep `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*DependentAdaptedList)(nil)

func NewDependentAdaptedList() *DependentAdaptedList {
    return (&DependentAdaptedList{})
}

func (x *DependentAdaptedList) GetField() []*DependentAdaptedListDep {
    if !x.IsSetField() {
        return make([]*DependentAdaptedListDep, 0)
    }

    return x.Field
}

func (x *DependentAdaptedList) SetFieldNonCompat(value []*DependentAdaptedListDep) *DependentAdaptedList {
    x.Field = value
    return x
}

func (x *DependentAdaptedList) SetField(value []*DependentAdaptedListDep) *DependentAdaptedList {
    x.Field = value
    return x
}

func (x *DependentAdaptedList) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *DependentAdaptedList) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Field
    if err := p.WriteListBegin(thrift.STRUCT, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := item.Write(p); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedList) readField1(p thrift.Format) error {  // Field
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]*DependentAdaptedListDep, 0, size)
for i := 0; i < size; i++ {
    var elem DependentAdaptedListDep
    {
        result := *NewDependentAdaptedListDep()
err := result.Read(p)
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, &elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult

    x.Field = result
    return nil
}

func (x *DependentAdaptedList) toString1() string {  // Field
    return fmt.Sprintf("%v", x.Field)
}



func (x *DependentAdaptedList) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("DependentAdaptedList"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedList) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.LIST)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DependentAdaptedList) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DependentAdaptedList({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type DependentAdaptedListDep struct {
    Field *int16 `thrift:"field,1,optional" json:"field,omitempty" db:"field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*DependentAdaptedListDep)(nil)

func NewDependentAdaptedListDep() *DependentAdaptedListDep {
    return (&DependentAdaptedListDep{})
}

func (x *DependentAdaptedListDep) GetField() int16 {
    if !x.IsSetField() {
        return 0
    }

    return *x.Field
}

func (x *DependentAdaptedListDep) SetFieldNonCompat(value int16) *DependentAdaptedListDep {
    x.Field = &value
    return x
}

func (x *DependentAdaptedListDep) SetField(value *int16) *DependentAdaptedListDep {
    x.Field = value
    return x
}

func (x *DependentAdaptedListDep) IsSetField() bool {
    return x != nil && x.Field != nil
}

func (x *DependentAdaptedListDep) writeField1(p thrift.Format) error {  // Field
    if !x.IsSetField() {
        return nil
    }

    if err := p.WriteFieldBegin("field", thrift.I16, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.Field
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedListDep) readField1(p thrift.Format) error {  // Field
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.Field = &result
    return nil
}

func (x *DependentAdaptedListDep) toString1() string {  // Field
    if x.IsSetField() {
        return fmt.Sprintf("%v", *x.Field)
    }
    return fmt.Sprintf("%v", x.Field)
}




func (x *DependentAdaptedListDep) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("DependentAdaptedListDep"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DependentAdaptedListDep) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I16)):  // field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DependentAdaptedListDep) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DependentAdaptedListDep({")
    sb.WriteString(fmt.Sprintf("Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type AllocatorAware struct {
    AaList ListI32_9187 `thrift:"aa_list,1" json:"aa_list" db:"aa_list"`
    AaSet SetI32_7070 `thrift:"aa_set,2" json:"aa_set" db:"aa_set"`
    AaMap MapI32I32_9565 `thrift:"aa_map,3" json:"aa_map" db:"aa_map"`
    AaString String_5252 `thrift:"aa_string,4" json:"aa_string" db:"aa_string"`
    NotAContainer int32 `thrift:"not_a_container,5" json:"not_a_container" db:"not_a_container"`
    AaUnique I32_9314 `thrift:"aa_unique,6" json:"aa_unique" db:"aa_unique"`
    AaShared I32_9314 `thrift:"aa_shared,7" json:"aa_shared" db:"aa_shared"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AllocatorAware)(nil)

func NewAllocatorAware() *AllocatorAware {
    return (&AllocatorAware{}).
        SetAaListNonCompat(NewListI32_9187()).
        SetAaSetNonCompat(NewSetI32_7070()).
        SetAaMapNonCompat(NewMapI32I32_9565()).
        SetAaStringNonCompat(NewString_5252()).
        SetNotAContainerNonCompat(0).
        SetAaUniqueNonCompat(NewI32_9314()).
        SetAaSharedNonCompat(NewI32_9314())
}

func (x *AllocatorAware) GetAaList() ListI32_9187 {
    if !x.IsSetAaList() {
        return NewListI32_9187()
    }

    return x.AaList
}

func (x *AllocatorAware) GetAaSet() SetI32_7070 {
    if !x.IsSetAaSet() {
        return NewSetI32_7070()
    }

    return x.AaSet
}

func (x *AllocatorAware) GetAaMap() MapI32I32_9565 {
    if !x.IsSetAaMap() {
        return NewMapI32I32_9565()
    }

    return x.AaMap
}

func (x *AllocatorAware) GetAaString() String_5252 {
    return x.AaString
}

func (x *AllocatorAware) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware) GetAaUnique() I32_9314 {
    return x.AaUnique
}

func (x *AllocatorAware) GetAaShared() I32_9314 {
    return x.AaShared
}

func (x *AllocatorAware) SetAaListNonCompat(value ListI32_9187) *AllocatorAware {
    x.AaList = value
    return x
}

func (x *AllocatorAware) SetAaList(value ListI32_9187) *AllocatorAware {
    x.AaList = value
    return x
}

func (x *AllocatorAware) SetAaSetNonCompat(value SetI32_7070) *AllocatorAware {
    x.AaSet = value
    return x
}

func (x *AllocatorAware) SetAaSet(value SetI32_7070) *AllocatorAware {
    x.AaSet = value
    return x
}

func (x *AllocatorAware) SetAaMapNonCompat(value MapI32I32_9565) *AllocatorAware {
    x.AaMap = value
    return x
}

func (x *AllocatorAware) SetAaMap(value MapI32I32_9565) *AllocatorAware {
    x.AaMap = value
    return x
}

func (x *AllocatorAware) SetAaStringNonCompat(value String_5252) *AllocatorAware {
    x.AaString = value
    return x
}

func (x *AllocatorAware) SetAaString(value String_5252) *AllocatorAware {
    x.AaString = value
    return x
}

func (x *AllocatorAware) SetNotAContainerNonCompat(value int32) *AllocatorAware {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware) SetNotAContainer(value int32) *AllocatorAware {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware) SetAaUniqueNonCompat(value I32_9314) *AllocatorAware {
    x.AaUnique = value
    return x
}

func (x *AllocatorAware) SetAaUnique(value I32_9314) *AllocatorAware {
    x.AaUnique = value
    return x
}

func (x *AllocatorAware) SetAaSharedNonCompat(value I32_9314) *AllocatorAware {
    x.AaShared = value
    return x
}

func (x *AllocatorAware) SetAaShared(value I32_9314) *AllocatorAware {
    x.AaShared = value
    return x
}

func (x *AllocatorAware) IsSetAaList() bool {
    return x != nil && x.AaList != nil
}

func (x *AllocatorAware) IsSetAaSet() bool {
    return x != nil && x.AaSet != nil
}

func (x *AllocatorAware) IsSetAaMap() bool {
    return x != nil && x.AaMap != nil
}

func (x *AllocatorAware) writeField1(p thrift.Format) error {  // AaList
    if err := p.WriteFieldBegin("aa_list", thrift.LIST, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AaList
    err := WriteListI32_9187(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField2(p thrift.Format) error {  // AaSet
    if err := p.WriteFieldBegin("aa_set", thrift.SET, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AaSet
    err := WriteSetI32_7070(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField3(p thrift.Format) error {  // AaMap
    if err := p.WriteFieldBegin("aa_map", thrift.MAP, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AaMap
    err := WriteMapI32I32_9565(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField4(p thrift.Format) error {  // AaString
    if err := p.WriteFieldBegin("aa_string", thrift.STRING, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AaString
    err := WriteString_5252(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField5(p thrift.Format) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.NotAContainer
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField6(p thrift.Format) error {  // AaUnique
    if err := p.WriteFieldBegin("aa_unique", thrift.I32, 6); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AaUnique
    err := WriteI32_9314(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) writeField7(p thrift.Format) error {  // AaShared
    if err := p.WriteFieldBegin("aa_shared", thrift.I32, 7); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AaShared
    err := WriteI32_9314(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) readField1(p thrift.Format) error {  // AaList
    result, err := ReadListI32_9187(p)
if err != nil {
    return err
}

    x.AaList = result
    return nil
}

func (x *AllocatorAware) readField2(p thrift.Format) error {  // AaSet
    result, err := ReadSetI32_7070(p)
if err != nil {
    return err
}

    x.AaSet = result
    return nil
}

func (x *AllocatorAware) readField3(p thrift.Format) error {  // AaMap
    result, err := ReadMapI32I32_9565(p)
if err != nil {
    return err
}

    x.AaMap = result
    return nil
}

func (x *AllocatorAware) readField4(p thrift.Format) error {  // AaString
    result, err := ReadString_5252(p)
if err != nil {
    return err
}

    x.AaString = result
    return nil
}

func (x *AllocatorAware) readField5(p thrift.Format) error {  // NotAContainer
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.NotAContainer = result
    return nil
}

func (x *AllocatorAware) readField6(p thrift.Format) error {  // AaUnique
    result, err := ReadI32_9314(p)
if err != nil {
    return err
}

    x.AaUnique = result
    return nil
}

func (x *AllocatorAware) readField7(p thrift.Format) error {  // AaShared
    result, err := ReadI32_9314(p)
if err != nil {
    return err
}

    x.AaShared = result
    return nil
}

func (x *AllocatorAware) toString1() string {  // AaList
    return fmt.Sprintf("%v", x.AaList)
}

func (x *AllocatorAware) toString2() string {  // AaSet
    return fmt.Sprintf("%v", x.AaSet)
}

func (x *AllocatorAware) toString3() string {  // AaMap
    return fmt.Sprintf("%v", x.AaMap)
}

func (x *AllocatorAware) toString4() string {  // AaString
    return fmt.Sprintf("%v", x.AaString)
}

func (x *AllocatorAware) toString5() string {  // NotAContainer
    return fmt.Sprintf("%v", x.NotAContainer)
}

func (x *AllocatorAware) toString6() string {  // AaUnique
    return fmt.Sprintf("%v", x.AaUnique)
}

func (x *AllocatorAware) toString7() string {  // AaShared
    return fmt.Sprintf("%v", x.AaShared)
}



func (x *AllocatorAware) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("AllocatorAware"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := x.writeField6(p); err != nil {
        return err
    }

    if err := x.writeField7(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.LIST)):  // aa_list
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.SET)):  // aa_set
            if err := x.readField2(p); err != nil {
                return err
            }
        case (id == 3 && wireType == thrift.Type(thrift.MAP)):  // aa_map
            if err := x.readField3(p); err != nil {
                return err
            }
        case (id == 4 && wireType == thrift.Type(thrift.STRING)):  // aa_string
            if err := x.readField4(p); err != nil {
                return err
            }
        case (id == 5 && wireType == thrift.Type(thrift.I32)):  // not_a_container
            if err := x.readField5(p); err != nil {
                return err
            }
        case (id == 6 && wireType == thrift.Type(thrift.I32)):  // aa_unique
            if err := x.readField6(p); err != nil {
                return err
            }
        case (id == 7 && wireType == thrift.Type(thrift.I32)):  // aa_shared
            if err := x.readField7(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AllocatorAware) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AllocatorAware({")
    sb.WriteString(fmt.Sprintf("AaList:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("AaSet:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("AaMap:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("AaString:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("NotAContainer:%s ", x.toString5()))
    sb.WriteString(fmt.Sprintf("AaUnique:%s ", x.toString6()))
    sb.WriteString(fmt.Sprintf("AaShared:%s", x.toString7()))
    sb.WriteString("})")

    return sb.String()
}

type AllocatorAware2 struct {
    NotAContainer int32 `thrift:"not_a_container,1" json:"not_a_container" db:"not_a_container"`
    BoxField *int32 `thrift:"box_field,2,optional" json:"box_field,omitempty" db:"box_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*AllocatorAware2)(nil)

func NewAllocatorAware2() *AllocatorAware2 {
    return (&AllocatorAware2{}).
        SetNotAContainerNonCompat(0)
}

func (x *AllocatorAware2) GetNotAContainer() int32 {
    return x.NotAContainer
}

func (x *AllocatorAware2) GetBoxField() int32 {
    if !x.IsSetBoxField() {
        return 0
    }

    return *x.BoxField
}

func (x *AllocatorAware2) SetNotAContainerNonCompat(value int32) *AllocatorAware2 {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware2) SetNotAContainer(value int32) *AllocatorAware2 {
    x.NotAContainer = value
    return x
}

func (x *AllocatorAware2) SetBoxFieldNonCompat(value int32) *AllocatorAware2 {
    x.BoxField = &value
    return x
}

func (x *AllocatorAware2) SetBoxField(value *int32) *AllocatorAware2 {
    x.BoxField = value
    return x
}

func (x *AllocatorAware2) IsSetBoxField() bool {
    return x != nil && x.BoxField != nil
}

func (x *AllocatorAware2) writeField1(p thrift.Format) error {  // NotAContainer
    if err := p.WriteFieldBegin("not_a_container", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.NotAContainer
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) writeField2(p thrift.Format) error {  // BoxField
    if !x.IsSetBoxField() {
        return nil
    }

    if err := p.WriteFieldBegin("box_field", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.BoxField
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) readField1(p thrift.Format) error {  // NotAContainer
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.NotAContainer = result
    return nil
}

func (x *AllocatorAware2) readField2(p thrift.Format) error {  // BoxField
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.BoxField = &result
    return nil
}

func (x *AllocatorAware2) toString1() string {  // NotAContainer
    return fmt.Sprintf("%v", x.NotAContainer)
}

func (x *AllocatorAware2) toString2() string {  // BoxField
    if x.IsSetBoxField() {
        return fmt.Sprintf("%v", *x.BoxField)
    }
    return fmt.Sprintf("%v", x.BoxField)
}




func (x *AllocatorAware2) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("AllocatorAware2"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AllocatorAware2) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // not_a_container
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.I32)):  // box_field
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AllocatorAware2) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AllocatorAware2({")
    sb.WriteString(fmt.Sprintf("NotAContainer:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("BoxField:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type TypedefStruct struct {
    I32Field int32 `thrift:"i32_field,1" json:"i32_field" db:"i32_field"`
    IntTypedefField IntTypedef `thrift:"IntTypedef_field,2" json:"IntTypedef_field" db:"IntTypedef_field"`
    UintTypedefField UintTypedef `thrift:"UintTypedef_field,3" json:"UintTypedef_field" db:"UintTypedef_field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*TypedefStruct)(nil)

func NewTypedefStruct() *TypedefStruct {
    return (&TypedefStruct{}).
        SetI32FieldNonCompat(0).
        SetIntTypedefFieldNonCompat(NewIntTypedef()).
        SetUintTypedefFieldNonCompat(NewUintTypedef())
}

func (x *TypedefStruct) GetI32Field() int32 {
    return x.I32Field
}

func (x *TypedefStruct) GetIntTypedefField() IntTypedef {
    return x.IntTypedefField
}

func (x *TypedefStruct) GetUintTypedefField() UintTypedef {
    return x.UintTypedefField
}

func (x *TypedefStruct) SetI32FieldNonCompat(value int32) *TypedefStruct {
    x.I32Field = value
    return x
}

func (x *TypedefStruct) SetI32Field(value int32) *TypedefStruct {
    x.I32Field = value
    return x
}

func (x *TypedefStruct) SetIntTypedefFieldNonCompat(value IntTypedef) *TypedefStruct {
    x.IntTypedefField = value
    return x
}

func (x *TypedefStruct) SetIntTypedefField(value IntTypedef) *TypedefStruct {
    x.IntTypedefField = value
    return x
}

func (x *TypedefStruct) SetUintTypedefFieldNonCompat(value UintTypedef) *TypedefStruct {
    x.UintTypedefField = value
    return x
}

func (x *TypedefStruct) SetUintTypedefField(value UintTypedef) *TypedefStruct {
    x.UintTypedefField = value
    return x
}

func (x *TypedefStruct) writeField1(p thrift.Format) error {  // I32Field
    if err := p.WriteFieldBegin("i32_field", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.I32Field
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) writeField2(p thrift.Format) error {  // IntTypedefField
    if err := p.WriteFieldBegin("IntTypedef_field", thrift.I32, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.IntTypedefField
    err := WriteIntTypedef(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) writeField3(p thrift.Format) error {  // UintTypedefField
    if err := p.WriteFieldBegin("UintTypedef_field", thrift.I32, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.UintTypedefField
    err := WriteUintTypedef(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) readField1(p thrift.Format) error {  // I32Field
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.I32Field = result
    return nil
}

func (x *TypedefStruct) readField2(p thrift.Format) error {  // IntTypedefField
    result, err := ReadIntTypedef(p)
if err != nil {
    return err
}

    x.IntTypedefField = result
    return nil
}

func (x *TypedefStruct) readField3(p thrift.Format) error {  // UintTypedefField
    result, err := ReadUintTypedef(p)
if err != nil {
    return err
}

    x.UintTypedefField = result
    return nil
}

func (x *TypedefStruct) toString1() string {  // I32Field
    return fmt.Sprintf("%v", x.I32Field)
}

func (x *TypedefStruct) toString2() string {  // IntTypedefField
    return fmt.Sprintf("%v", x.IntTypedefField)
}

func (x *TypedefStruct) toString3() string {  // UintTypedefField
    return fmt.Sprintf("%v", x.UintTypedefField)
}



func (x *TypedefStruct) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("TypedefStruct"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *TypedefStruct) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // i32_field
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.I32)):  // IntTypedef_field
            if err := x.readField2(p); err != nil {
                return err
            }
        case (id == 3 && wireType == thrift.Type(thrift.I32)):  // UintTypedef_field
            if err := x.readField3(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *TypedefStruct) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("TypedefStruct({")
    sb.WriteString(fmt.Sprintf("I32Field:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("IntTypedefField:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("UintTypedefField:%s", x.toString3()))
    sb.WriteString("})")

    return sb.String()
}

type StructWithDoubleUnderscores struct {
    _Field int32 `thrift:"__field,1" json:"__field" db:"__field"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*StructWithDoubleUnderscores)(nil)

func NewStructWithDoubleUnderscores() *StructWithDoubleUnderscores {
    return (&StructWithDoubleUnderscores{}).
        Set_FieldNonCompat(0)
}

func (x *StructWithDoubleUnderscores) Get_Field() int32 {
    return x._Field
}

func (x *StructWithDoubleUnderscores) Set_FieldNonCompat(value int32) *StructWithDoubleUnderscores {
    x._Field = value
    return x
}

func (x *StructWithDoubleUnderscores) Set_Field(value int32) *StructWithDoubleUnderscores {
    x._Field = value
    return x
}

func (x *StructWithDoubleUnderscores) writeField1(p thrift.Format) error {  // _Field
    if err := p.WriteFieldBegin("__field", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x._Field
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) readField1(p thrift.Format) error {  // _Field
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x._Field = result
    return nil
}

func (x *StructWithDoubleUnderscores) toString1() string {  // _Field
    return fmt.Sprintf("%v", x._Field)
}



func (x *StructWithDoubleUnderscores) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("StructWithDoubleUnderscores"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *StructWithDoubleUnderscores) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // __field
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *StructWithDoubleUnderscores) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("StructWithDoubleUnderscores({")
    sb.WriteString(fmt.Sprintf("_Field:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("apache.org/thrift/fixtures/types/empty_struct", func() any { return NewEmptyStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/decorated_struct", func() any { return NewDecoratedStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ContainerStruct", func() any { return NewContainerStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CppTypeStruct", func() any { return NewCppTypeStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/VirtualStruct", func() any { return NewVirtualStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyStructWithForwardRefEnum", func() any { return NewMyStructWithForwardRefEnum() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TrivialNumeric", func() any { return NewTrivialNumeric() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TrivialNestedWithDefault", func() any { return NewTrivialNestedWithDefault() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ComplexString", func() any { return NewComplexString() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ComplexNestedWithDefault", func() any { return NewComplexNestedWithDefault() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MinPadding", func() any { return NewMinPadding() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MinPaddingWithCustomType", func() any { return NewMinPaddingWithCustomType() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyStruct", func() any { return NewMyStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyDataItem", func() any { return NewMyDataItem() })
    registry.RegisterType("apache.org/thrift/fixtures/types/Renaming", func() any { return NewRenaming() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AnnotatedTypes", func() any { return NewAnnotatedTypes() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageRoot", func() any { return NewForwardUsageRoot() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageStruct", func() any { return NewForwardUsageStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/ForwardUsageByRef", func() any { return NewForwardUsageByRef() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteMap", func() any { return NewIncompleteMap() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteMapDep", func() any { return NewIncompleteMapDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteMap", func() any { return NewCompleteMap() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteMapDep", func() any { return NewCompleteMapDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteList", func() any { return NewIncompleteList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/IncompleteListDep", func() any { return NewIncompleteListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteList", func() any { return NewCompleteList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/CompleteListDep", func() any { return NewCompleteListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AdaptedList", func() any { return NewAdaptedList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AdaptedListDep", func() any { return NewAdaptedListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/DependentAdaptedList", func() any { return NewDependentAdaptedList() })
    registry.RegisterType("apache.org/thrift/fixtures/types/DependentAdaptedListDep", func() any { return NewDependentAdaptedListDep() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AllocatorAware", func() any { return NewAllocatorAware() })
    registry.RegisterType("apache.org/thrift/fixtures/types/AllocatorAware2", func() any { return NewAllocatorAware2() })
    registry.RegisterType("apache.org/thrift/fixtures/types/TypedefStruct", func() any { return NewTypedefStruct() })
    registry.RegisterType("apache.org/thrift/fixtures/types/StructWithDoubleUnderscores", func() any { return NewStructWithDoubleUnderscores() })

    registry.RegisterType("apache.org/thrift/fixtures/types/has_bitwise_ops", func() any { return HasBitwiseOps(0) })
    registry.RegisterType("apache.org/thrift/fixtures/types/is_unscoped", func() any { return IsUnscoped(0) })
    registry.RegisterType("apache.org/thrift/fixtures/types/MyForwardRefEnum", func() any { return MyForwardRefEnum(0) })
}
