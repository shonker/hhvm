// @generated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
// This file is probably not the place you want to edit!

//! Client implementation for each service in `module`.

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, unused_imports, clippy::all)]


#[doc(inline)]
pub use :: as types;

pub mod errors;

pub(crate) use crate as client;
pub(crate) use ::::services;


/// Client definitions for `PubSubStreamingService`.
pub struct PubSubStreamingServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
    transport: T,
    _phantom: ::std::marker::PhantomData<fn() -> (P, S)>,
}

impl<P, T, S> PubSubStreamingServiceImpl<P, T, S>
where
    P: ::fbthrift::Protocol,
    T: ::fbthrift::Transport,
    P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
    ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    P::Deserializer: ::std::marker::Send,
    S: ::fbthrift::help::Spawner,
{
    pub fn new(
        transport: T,
    ) -> Self {
        Self {
            transport,
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn transport(&self) -> &T {
        &self.transport
    }


    fn _returnstream_impl(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.returnstream";
        }
        let args = self::Args_PubSubStreamingService_returnstream {
            i32_from: arg_i32_from,
            i32_to: arg_i32_to,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("returnstream", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.returnstream"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ReturnstreamStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::ReturnstreamStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ReturnstreamStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::ReturnstreamReader, S>(de)
                .await??
                .map(move |_| new_stream);
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.returnstream"))
        .boxed()
    }

    fn _streamthrows_impl(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.streamthrows";
        }
        let args = self::Args_PubSubStreamingService_streamthrows {
            foo: arg_foo,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("streamthrows", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.streamthrows"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::StreamthrowsStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::StreamthrowsStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::StreamthrowsStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::StreamthrowsReader, S>(de)
                .await??
                .map(move |_| new_stream);
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.streamthrows"))
        .boxed()
    }

    fn _servicethrows_impl(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.servicethrows";
        }
        let args = self::Args_PubSubStreamingService_servicethrows {
            foo: arg_foo,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("servicethrows", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.servicethrows"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ServicethrowsStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::ServicethrowsStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ServicethrowsStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::ServicethrowsReader, S>(de)
                .await??
                .map(move |_| new_stream);
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.servicethrows"))
        .boxed()
    }

    fn _servicethrows2_impl(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.servicethrows2";
        }
        let args = self::Args_PubSubStreamingService_servicethrows2 {
            foo: arg_foo,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("servicethrows2", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.servicethrows2"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::Servicethrows2StreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::Servicethrows2StreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::Servicethrows2StreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::Servicethrows2Reader, S>(de)
                .await??
                .map(move |_| new_stream);
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.servicethrows2"))
        .boxed()
    }

    fn _boththrows_impl(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.boththrows";
        }
        let args = self::Args_PubSubStreamingService_boththrows {
            foo: arg_foo,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("boththrows", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.boththrows"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::BoththrowsStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::BoththrowsStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::BoththrowsStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::BoththrowsReader, S>(de)
                .await??
                .map(move |_| new_stream);
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.boththrows"))
        .boxed()
    }

    fn _responseandstreamstreamthrows_impl(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.responseandstreamstreamthrows";
        }
        let args = self::Args_PubSubStreamingService_responseandstreamstreamthrows {
            foo: arg_foo,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("responseandstreamstreamthrows", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.responseandstreamstreamthrows"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsReader, S>(de)
                .await??
                .map(move |initial| (initial, new_stream));
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.responseandstreamstreamthrows"))
        .boxed()
    }

    fn _responseandstreamservicethrows_impl(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.responseandstreamservicethrows";
        }
        let args = self::Args_PubSubStreamingService_responseandstreamservicethrows {
            foo: arg_foo,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("responseandstreamservicethrows", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.responseandstreamservicethrows"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsReader, S>(de)
                .await??
                .map(move |initial| (initial, new_stream));
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.responseandstreamservicethrows"))
        .boxed()
    }

    fn _responseandstreamboththrows_impl(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.responseandstreamboththrows";
        }
        let args = self::Args_PubSubStreamingService_responseandstreamboththrows {
            foo: arg_foo,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("responseandstreamboththrows", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.responseandstreamboththrows"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsReader, S>(de)
                .await??
                .map(move |initial| (initial, new_stream));
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.responseandstreamboththrows"))
        .boxed()
    }

    fn _returnstreamFast_impl(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>> {
        use ::const_cstr::const_cstr;
        use ::tracing::Instrument as _;
        use ::futures::FutureExt as _;
        use ::futures::StreamExt as _;
        use ::fbthrift::Deserialize as _;

        const_cstr! {
            SERVICE_NAME = "PubSubStreamingService";
            SERVICE_METHOD_NAME = "PubSubStreamingService.returnstreamFast";
        }
        let args = self::Args_PubSubStreamingService_returnstreamFast {
            i32_from: arg_i32_from,
            i32_to: arg_i32_to,
            _phantom: ::std::marker::PhantomData,
        };

        let transport = self.transport();

        // need to do call setup outside of async block because T: Transport isn't Send
        let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("returnstreamFast", &args) {
            ::std::result::Result::Ok(res) => res,
            ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
        };

        let call_stream = transport
            .call_stream(SERVICE_NAME.as_cstr(), SERVICE_METHOD_NAME.as_cstr(), request_env, rpc_options)
            .instrument(::tracing::trace_span!("call_stream", method = "PubSubStreamingService.returnstreamFast"));

        async move {
            let (initial, stream) = call_stream.await?;

            let new_stream = stream.then(|item_res| {
                async move {
                    match item_res {
                        ::std::result::Result::Err(err) =>
                            ::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError::from(err)),
                        ::std::result::Result::Ok(item_enc) => {
                            S::spawn(move || {
                                match item_enc {
                                    ::fbthrift::ClientStreamElement::Reply(payload) => {
                                        let mut de = P::deserializer(payload);
                                        <crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de)
                                    }
                                    ::fbthrift::ClientStreamElement::ApplicationEx(payload) => {
                                        let mut de = P::deserializer(payload);
                                        let aexn = ::fbthrift::ApplicationException::read(&mut de)?;
                                        ::std::result::Result::Ok(::std::result::Result::Err(crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError::ApplicationException(aexn)))
                                    }
                                }
                            }).await.map_err(::anyhow::Error::from)??
                        }
                    }
                }
            })
            .boxed();

            let de = P::deserializer(initial);
            let res = ::fbthrift::help::async_deserialize_response_envelope::<P, crate::errors::pub_sub_streaming_service::ReturnstreamFastReader, S>(de)
                .await??
                .map(move |_| new_stream);
            res
        }
        .instrument(::tracing::info_span!("stream", method = "PubSubStreamingService.returnstreamFast"))
        .boxed()
    }
}

pub trait PubSubStreamingService: ::std::marker::Send {
    fn returnstream(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>>;

    fn streamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>>;

    fn servicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>>;

    fn servicethrows2(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>>;

    fn boththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>>;

    fn responseandstreamstreamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>>;

    fn responseandstreamservicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>>;

    fn responseandstreamboththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>>;

    fn returnstreamFast(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>>;
}

pub trait PubSubStreamingServiceExt<T>: PubSubStreamingService
where
    T: ::fbthrift::Transport,
{
    fn returnstream_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>>;
    fn streamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>>;
    fn servicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>>;
    fn servicethrows2_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>>;
    fn boththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>>;
    fn responseandstreamstreamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>>;
    fn responseandstreamservicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>>;
    fn responseandstreamboththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>>;
    fn returnstreamFast_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>>;

    fn transport(&self) -> &T;
}

struct Args_PubSubStreamingService_returnstream<'a> {
    i32_from: ::std::primitive::i32,
    i32_to: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_returnstream<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.returnstream"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("i32_from", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.i32_from, p);
        p.write_field_end();
        p.write_field_begin("i32_to", ::fbthrift::TType::I32, 2i16);
        ::fbthrift::Serialize::write(&self.i32_to, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_streamthrows<'a> {
    foo: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_streamthrows<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.streamthrows"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("foo", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.foo, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_servicethrows<'a> {
    foo: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_servicethrows<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.servicethrows"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("foo", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.foo, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_servicethrows2<'a> {
    foo: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_servicethrows2<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.servicethrows2"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("foo", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.foo, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_boththrows<'a> {
    foo: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_boththrows<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.boththrows"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("foo", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.foo, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_responseandstreamstreamthrows<'a> {
    foo: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_responseandstreamstreamthrows<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.responseandstreamstreamthrows"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("foo", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.foo, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_responseandstreamservicethrows<'a> {
    foo: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_responseandstreamservicethrows<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.responseandstreamservicethrows"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("foo", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.foo, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_responseandstreamboththrows<'a> {
    foo: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_responseandstreamboththrows<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.responseandstreamboththrows"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("foo", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.foo, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

struct Args_PubSubStreamingService_returnstreamFast<'a> {
    i32_from: ::std::primitive::i32,
    i32_to: ::std::primitive::i32,
    _phantom: ::std::marker::PhantomData<&'a ()>,
}

impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_PubSubStreamingService_returnstreamFast<'a> {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "PubSubStreamingService.returnstreamFast"))]
    fn write(&self, p: &mut P) {
        p.write_struct_begin("args");
        p.write_field_begin("i32_from", ::fbthrift::TType::I32, 1i16);
        ::fbthrift::Serialize::write(&self.i32_from, p);
        p.write_field_end();
        p.write_field_begin("i32_to", ::fbthrift::TType::I32, 2i16);
        ::fbthrift::Serialize::write(&self.i32_to, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P, T, S> PubSubStreamingService for PubSubStreamingServiceImpl<P, T, S>
where
    P: ::fbthrift::Protocol,
    T: ::fbthrift::Transport,
    P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
    ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    P::Deserializer: ::std::marker::Send,
    S: ::fbthrift::help::Spawner,
{
    fn returnstream(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>> {
        let rpc_options = T::RpcOptions::default();
        self._returnstream_impl(
            arg_i32_from,
            arg_i32_to,
            rpc_options,
        )
    }
    fn streamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>> {
        let rpc_options = T::RpcOptions::default();
        self._streamthrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn servicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>> {
        let rpc_options = T::RpcOptions::default();
        self._servicethrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn servicethrows2(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>> {
        let rpc_options = T::RpcOptions::default();
        self._servicethrows2_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn boththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>> {
        let rpc_options = T::RpcOptions::default();
        self._boththrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamstreamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>> {
        let rpc_options = T::RpcOptions::default();
        self._responseandstreamstreamthrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamservicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>> {
        let rpc_options = T::RpcOptions::default();
        self._responseandstreamservicethrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamboththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>> {
        let rpc_options = T::RpcOptions::default();
        self._responseandstreamboththrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn returnstreamFast(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>> {
        let rpc_options = T::RpcOptions::default();
        self._returnstreamFast_impl(
            arg_i32_from,
            arg_i32_to,
            rpc_options,
        )
    }
}

impl<P, T, S> PubSubStreamingServiceExt<T> for PubSubStreamingServiceImpl<P, T, S>
where
    P: ::fbthrift::Protocol,
    T: ::fbthrift::Transport,
    P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
    ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    P::Deserializer: ::std::marker::Send,
    S: ::fbthrift::help::Spawner,
{
    fn returnstream_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>> {
        self._returnstream_impl(
            arg_i32_from,
            arg_i32_to,
            rpc_options,
        )
    }
    fn streamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>> {
        self._streamthrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn servicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>> {
        self._servicethrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn servicethrows2_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>> {
        self._servicethrows2_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn boththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>> {
        self._boththrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamstreamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>> {
        self._responseandstreamstreamthrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamservicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>> {
        self._responseandstreamservicethrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamboththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>> {
        self._responseandstreamboththrows_impl(
            arg_foo,
            rpc_options,
        )
    }
    fn returnstreamFast_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>> {
        self._returnstreamFast_impl(
            arg_i32_from,
            arg_i32_to,
            rpc_options,
        )
    }

    fn transport(&self) -> &T {
      self.transport()
    }
}

#[allow(deprecated)]
impl<'a, S> PubSubStreamingService for S
where
    S: ::std::convert::AsRef<dyn PubSubStreamingService + 'a>,
    S: ::std::marker::Send,
{
    fn returnstream(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>> {
        self.as_ref().returnstream(
            arg_i32_from,
            arg_i32_to,
        )
    }
    fn streamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>> {
        self.as_ref().streamthrows(
            arg_foo,
        )
    }
    fn servicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>> {
        self.as_ref().servicethrows(
            arg_foo,
        )
    }
    fn servicethrows2(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>> {
        self.as_ref().servicethrows2(
            arg_foo,
        )
    }
    fn boththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>> {
        self.as_ref().boththrows(
            arg_foo,
        )
    }
    fn responseandstreamstreamthrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>> {
        self.as_ref().responseandstreamstreamthrows(
            arg_foo,
        )
    }
    fn responseandstreamservicethrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>> {
        self.as_ref().responseandstreamservicethrows(
            arg_foo,
        )
    }
    fn responseandstreamboththrows(
        &self,
        arg_foo: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>> {
        self.as_ref().responseandstreamboththrows(
            arg_foo,
        )
    }
    fn returnstreamFast(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>> {
        self.as_ref().returnstreamFast(
            arg_i32_from,
            arg_i32_to,
        )
    }
}

#[allow(deprecated)]
impl<S, T> PubSubStreamingServiceExt<T> for S
where
    S: ::std::convert::AsRef<dyn PubSubStreamingService + 'static>,
    S: ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T> + 'static>,
    S: ::std::marker::Send,
    T: ::fbthrift::Transport,
{
    fn returnstream_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).returnstream_with_rpc_opts(
            arg_i32_from,
            arg_i32_to,
            rpc_options,
        )
    }
    fn streamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, crate::errors::pub_sub_streaming_service::StreamthrowsError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).streamthrows_with_rpc_opts(
            arg_foo,
            rpc_options,
        )
    }
    fn servicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, crate::errors::pub_sub_streaming_service::ServicethrowsError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).servicethrows_with_rpc_opts(
            arg_foo,
            rpc_options,
        )
    }
    fn servicethrows2_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, crate::errors::pub_sub_streaming_service::Servicethrows2Error>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).servicethrows2_with_rpc_opts(
            arg_foo,
            rpc_options,
        )
    }
    fn boththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, crate::errors::pub_sub_streaming_service::BoththrowsError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).boththrows_with_rpc_opts(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamstreamthrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).responseandstreamstreamthrows_with_rpc_opts(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamservicethrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).responseandstreamservicethrows_with_rpc_opts(
            arg_foo,
            rpc_options,
        )
    }
    fn responseandstreamboththrows_with_rpc_opts(
        &self,
        arg_foo: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).responseandstreamboththrows_with_rpc_opts(
            arg_foo,
            rpc_options,
        )
    }
    fn returnstreamFast_with_rpc_opts(
        &self,
        arg_i32_from: ::std::primitive::i32,
        arg_i32_to: ::std::primitive::i32,
        rpc_options: T::RpcOptions,
    ) -> ::futures::future::BoxFuture<'static, ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, crate::errors::pub_sub_streaming_service::ReturnstreamFastError>> {
        <Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self).returnstreamFast_with_rpc_opts(
            arg_i32_from,
            arg_i32_to,
            rpc_options,
        )
    }

    fn transport(&self) -> &T {
        <dyn PubSubStreamingServiceExt<T> as PubSubStreamingServiceExt<T>>::transport(<Self as ::std::convert::AsRef<dyn PubSubStreamingServiceExt<T>>>::as_ref(self))
    }
}

#[derive(Clone)]
pub struct make_PubSubStreamingService;

/// To be called by user directly setting up a client. Avoids
/// needing ClientFactory trait in scope, avoids unidiomatic
/// make_Trait name.
///
/// ```
/// # const _: &str = stringify! {
/// use bgs::client::BuckGraphService;
///
/// let protocol = BinaryProtocol::new();
/// let transport = HttpClient::new();
/// let client = <dyn BuckGraphService>::new(protocol, transport);
/// # };
/// ```
impl dyn PubSubStreamingService {
    pub fn new<P, T>(
        protocol: P,
        transport: T,
    ) -> ::std::sync::Arc<impl PubSubStreamingService + ::std::marker::Send + ::std::marker::Sync + 'static>
    where
        P: ::fbthrift::Protocol<Frame = T>,
        T: ::fbthrift::Transport,
        P::Deserializer: ::std::marker::Send,
    {
        let spawner = ::fbthrift::help::NoopSpawner;
        Self::with_spawner(protocol, transport, spawner)
    }

    pub fn with_spawner<P, T, S>(
        protocol: P,
        transport: T,
        spawner: S,
    ) -> ::std::sync::Arc<impl PubSubStreamingService + ::std::marker::Send + ::std::marker::Sync + 'static>
    where
        P: ::fbthrift::Protocol<Frame = T>,
        T: ::fbthrift::Transport,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        let _ = protocol;
        let _ = spawner;
        ::std::sync::Arc::new(PubSubStreamingServiceImpl::<P, T, S>::new(transport))
    }
}

impl<T> dyn PubSubStreamingServiceExt<T>
where
    T: ::fbthrift::Transport,
{
    pub fn new<P>(
        protocol: P,
        transport: T,
    ) -> ::std::sync::Arc<impl PubSubStreamingServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
    where
        P: ::fbthrift::Protocol<Frame = T>,
        P::Deserializer: ::std::marker::Send,
    {
        let spawner = ::fbthrift::help::NoopSpawner;
        Self::with_spawner(protocol, transport, spawner)
    }

    pub fn with_spawner<P, S>(
        protocol: P,
        transport: T,
        spawner: S,
    ) -> ::std::sync::Arc<impl PubSubStreamingServiceExt<T> + ::std::marker::Send + ::std::marker::Sync + 'static>
    where
        P: ::fbthrift::Protocol<Frame = T>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        let _ = protocol;
        let _ = spawner;
        ::std::sync::Arc::new(PubSubStreamingServiceImpl::<P, T, S>::new(transport))
    }
}

pub type PubSubStreamingServiceDynClient = <make_PubSubStreamingService as ::fbthrift::ClientFactory>::Api;
pub type PubSubStreamingServiceClient = ::std::sync::Arc<PubSubStreamingServiceDynClient>;

/// The same thing, but to be called from generic contexts where we are
/// working with a type parameter `C: ClientFactory` to produce clients.
impl ::fbthrift::ClientFactory for make_PubSubStreamingService {
    type Api = dyn PubSubStreamingService + ::std::marker::Send + ::std::marker::Sync + 'static;

    fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
    where
        P: ::fbthrift::Protocol<Frame = T>,
        T: ::fbthrift::Transport,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        <dyn PubSubStreamingService>::with_spawner(protocol, transport, spawner)
    }
}

